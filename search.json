[{"title":"备考导学【一】","url":"//备考导学【一】","content":"\n一级建造师备考总结：\n\n[![jWaoLQ.png](https://s1.ax1x.com/2022/07/14/jWaoLQ.png)](https://imgtu.com/i/jWaoLQ)\n\n重视选择题，案例题多练习！\n\n[![jWaxQU.png](https://s1.ax1x.com/2022/07/14/jWaxQU.png)](https://imgtu.com/i/jWaxQU)\n\n考试情况分析\n\n选择题：\n\n```\n离散性强: 一定要通读教材\n```\n\n```\n高度依托教材\n```\n\n案例题：\n\n```\n体量大，背景复杂，有效信息多\n```\n\n```\n管理和技术结合更为紧密\n```\n\n```\n对综合能力有了更高的要求\n```\n\n```\n与现场实际结合越来越紧密（实操）\n```\n\n二、基本题型分析：\n\n选择：\n\n```\n定义：  关键词\n```\n\n```\n参数： 数字 归纳总结\n```\n\n```\n分类：多选易考\n```\n\n```\n判断：多选易考\n```\n\n```\n排序：技术排序  管理排序\n```\n\n```\n计算：分析为主 例如计算钢筋的外露长度\n```\n\n案例：\n\n```\n简答：内容、方法、标准（规范）考记忆\n```\n\n```\n识图：结构图、构造图、双代号、单代号、横道图\n```\n\n```\n分析：造成什么什么的原因\n```\n\n```\n计算：理论计算、数学（数学逻辑思维）\n```\n\n```\n判断：\n```\n\n```\n排序：流程类的排序题（工艺的流程）、补全类的流程（缺谁补谁）\n```\n\n案例题的命题规律：五大模块\n\n```\n路基：\n```\n\n```\n路面：\n```\n\n```\n桥梁：\n```\n\n```\n隧道：\n```\n\n```\n综合：\n```\n\n案例分析技巧：\n\n```\n通读背景\n```\n\n```\n细审问题\n```\n\n```\n规范作答\n```\n\n教材的知识体系：\n\n[![jWdop6.png](https://s1.ax1x.com/2022/07/14/jWdop6.png)](https://imgtu.com/i/jWdop6)\n\n```\n路基：考点多，灵活，细节\n路面：杂：需要梳理 考点少 /题型单一/重复率高 难点：工地试验(应用分析)/造价\n桥梁：理解为主\n隧道：100% 掌握\n```\n\n[![jWw0De.png](https://s1.ax1x.com/2022/07/14/jWw0De.png)](https://imgtu.com/i/jWw0De)\n\n","tags":["一建"],"categories":["一建"]},{"title":"数据结构与算法【一】","url":"/2022/07/05/数据结构与算法【一】/","content":"\n#### 数据结构的概述\n\n```\n狭义：\n\t数据结构是专门研究数据存储的问题 \n    数据的存储包含两个方面：个体的存储 + 个体的关系的存储\n广义：\n\t数据结构既包含数据的存储也包含数据的操作\n\t对存储数据的操作就是算法\n```\n\n算法\n\n```\n狭义：\n    算法是和数据的存储方式密切相关\n广义：\n\t算法和数据的存储方式无关\n\t这就是泛型的思想\t\n```\n\n数据的存储结构有几种\n\n```\n线性\n\t连续存储【数组】\n\t\t优点：存取速度很快\n\t\t缺点：插入删除元素很慢，空间通常是有限制的\n\t离散存储【链表】\n\t\t优点：空间没有限制，插入删除元素很快\t\n\t\t缺点：存取速度慢\t\t\n```\n\n线性结构的应用\n\n```\n栈\n队列\n```\n\n非线性\n\n```\n树\n图\n```\n\n结题的方法和步骤\n\n```\n衡量算法的标准\n\t1、时间复杂度\n\t\t大概程序要执行的次数，而非执行的时间。\n\t\t\n\t2、空间复杂度\n\t\t算法执行过程中大概所占用的最大内存\n\t\t\n\t3、难易程度（主要是应用方面看重）\n\t\n\t4、健壮性（不能别人给一个非法的输入就挂掉）\n```\n\n数据结构的地位\n\n```\n\t数据结构是软件中最核心的课程\n```\n\n按数据结构的思路理解数据库\n\n```\n字段（一个属性）\n记录（一个事务）\n表（一类事务的集合）\n外键表示事务与事务之间的关系\n```\n\n```\n程序 = 数据的存储 + 数据的操作 + 可以被计算机执行的语言\n```\n\n#### 预备知识\n\n2.1 指针概述\n\n```\n指针的重要性：内存是可以被CPU直接访问的，硬盘不行，主要靠地址总线、数据总线、控制总线访问内存。内存分为很多格子单元，格子编号范围是0-4G-1。地址总线确定对哪个单元进行操作，数据总线确定是读还是写。\n```\n\n```\n指针是C语言的 灵魂\n```\n\n```\n地址  \n    地址就是内存单元的编号\n    从0开始的非负整数\n    范围：0--FFFFFFFF[0-4G-1]（地址线是32位，刚好控制2的32次）\n指针：  \n    指针就是地址  地址就是指针\n    指针变量是存放内存单元地址的变量\n    指针的本质是一个操作受限的非负整数（不能加乘除，只能减）\n```\n\n2.2 基本类型的指针\n\n```c\n# include <stdio.h>\nint main(void)\n{\n\tint * p; //p是个变量名字, int * 表示该p变量只能存储int类型变量的地址\n\tint i = 10;\n\tint j;\n\n\tp = &i; // p指向变量i的地址\n\t*p = i; // 等价于 i = i;\n//\tj = *p; // 等价于 j = i;\n\tprintf(\"i = %d, j = %d, *p = %d\\n\", i, j, *p);\t\n\treturn 0;\n} \n```\n\n```c\n    int i=10;  \n    int *p = &i; //等价于 int *p;\tp = &i;   表示*p的值是变量i的地址\n```\n\n详解这两部操作：\n\n```\n1. p存放了i的地址，所以我们说p指向了i\n2. p和i是完全不同的两个变量，修改其中的任意一个变量的值，不会影响另一变量的值\n3. p指向i，*p就是i变量本身。更形象的说所有出现*p的地方都可以换成i，所有出现i的地方都可以换成*p\n```\n\n总结\n\n```\n1、 如何一个指针变量(假定为p)存放了某个普通变量(假定为i)的地址，那我们就可以说：“p指向了i”， 但p与i是两个不同的变量，修改p的值不影响i的值，修改i的值不影响p的值.\n2、 *p等价于i 或者说*p可以与i在任何地方互换\n3、 如果一个指针变量指向了某个普通变量，则*指针变量 就完全等价于 该普通变量\n\n注意：\n指针变量也是变量，只不过它存放的不能是内存单元的内容，只能存放内存单元的地址\n普通变量前不能加*\n常量和表达式前不能加&\n```\n\n```\n# include <stdio.h>\nvoid f(int i) \n{\n\t*p = 100;\n}\nint main(void)\n{\n\tint i = 9;\n\tf(i);\n\tprintf(\"i = %d\\n\", i);\n\treturn 0;\n}\n//最后输出结果为9，因为局部变量只能在本函数内部使用。\n```\n\n```\n# include <stdio.h>\nvoid f(int * p) //不是定义了一个名字叫做*p的形参, 而是定义了一个形参，该形参名字叫做p,它的类型是int *\n{\n\t*p = 100; //i的地址发送给p，*p就是i，即100赋给i，i变成了100\n}\n\nint main(void)\n{\n\tint i = 9;\n\tf(&i);\n\tprintf(\"i = %d\\n\", i);\n\treturn 0;\n}\t\n最后输出结果为100\n```\n\n```\n总结：\n如何通过被调函数修改主调函数中普通变量的值：\n\n Ⅰ 实参为相关变量的地址 &i\n Ⅱ 形参为以该变量的类型为类型的指针变量 int * p\n Ⅲ 在被调函数中通过 *形参变量名 的方式就可以修改主函数相关变量的值 *p = 100\n```\n\n2.3 指针和数组的关系\n\n指针和一维数组\n\n```\n    数组名  \n        一维数组名是个指针常量，  \n        它存放的是一维数组第一个元素的地址， \n        它的值不能被改变  \n        一维数组名指向的是数组的第一个元素，即a指向的是a[0]  \n    下标和指针的关系  \n        a[i] <<==>> *(a+i)  \n```\n\n```\n    数组名  \n        一维数组名是个指针常量，  \n        它存放的是一维数组第一个元素的地址， \n        它的值不能被改变  \n        一维数组名指向的是数组的第一个元素，即a指向的是a[0]  \n    下标和指针的关系  \n        a[i] <<==>> *(a+i)  \n```\n\n```\n# include <stdio.h>\nint main(void)\n{\n    int a[5] = {1,2,3,4,5};\n    //a[3] == *(3+a);\n    printf(\"%p\\n\", a+1);\n    printf(\"%p\\n\", a+2);\n    printf(\"%d\\n\", *a+3); //*a+3等价于 a[0]+3\n    return 0;\n}\n```\n\n```\n假设指针变量的名字为p\n则p+i的值是p+i*(p所指向的变量所占的字节数)\n\n指针变量的运算\n指针变量不能相加，不能相乘，不能相除\n如果两指针变量属于同一数组，则可以相减\n指针变量可以加减一整数，前提是最终结果不能超过指针允许指向的范围\np+i的值是p+i*(p所指向的变量所占的字节数)\np-i的值是p-i*(p所指向的变量所占的字节数)\np++ <==> p+1\np-- <==> p-1\n```\n\n```\n如何通过被调函数修改主调函数中一维数组的内容【如何界定一维数组】\n    两个参数\n        存放数组首元素的指针变量\n        存放数组元素长度的整型变量\n```\n\n```\n# include <stdio.h>\nint main(void)\n{\n    double * p;\n    double x = 66.6;\n\n    p = &x;  //x占8个子节 1个字节是8位, 1个子节一个地址\n\n    double arr[3] = {1.1, 2.2, 3.3};\n    double * q;\n\n    q = &arr[0];\n    printf(\"%p\\n\", q);  //%p实际就是以十六进制输出\n    q = &arr[1];\n    printf(\"%p\\n\", q);  \n\n    return 0;\n}\n//输出：0012FF5C 00122FF64 C=12 5C+8=64\n```\n\n```\n通过函数修改实参的值\n要想修改一个变量的值，如果函数没有返回值，只能在函数中放入地址用指针：\n```\n\n```\n# include <stdio.h>\nvoid f(int * p);//前置声明\n\nint main(void)\n{\n    int i = 10;\n\n    f(&i);\n    printf(\"i = %d\\n\", i);\n\n    return 0;\n}\n\nvoid f(int * p)\n{\n    *p = 99;\n}\n```\n\n```c\n# include <stdio.h>\nvoid f(int ** q);\nint main(void)\n{\n    int i = 9;\n    int * p = &i;// int  *p;  p = &i;\n\n    printf(\"%p\\n\", p);\n    f(&p);\n    printf(\"%p\\n\", p);\n\n    return 0;\n}\n//p是int *类型，则&p是int **类型，指针的指针。把p的地址发送给q，*q=p\nvoid f(int ** q)\n{\n    *q = (int *)0xFFFFFFFF;\n}\n```\n\n2.4 结构体\n\n```\n为什么会出现结构体\n\t\t为了表示一些复杂的数据，而普通的基本类型变量无法满足要求\n\t\n什么叫结构体\n\t\t结构体是用户根据实际需要自己定义的复合数据类型\n        结构体相当于java中的类，但是里面没有方法\n\t\n如何使用结构体\n\t\t两种方式：\n\t\t\tstruct Student st = {1000, \"zhangsan\", 20}\n\t\t\tstruct Student * pst = &st;\n\t\t\t\n\t\t\t1.\n\t\t\t\tst.sid\n\t\t\t2.\n\t\t\t \tpst->sid\n\t\t\t \t表示pst所指向的结构体变量中的sid这个成员\n```\n\n使用结构体变量的第一种方式：\n\n```c\n# include <stdio.h>\n# include <string.h>\n\nstruct Student\n{\t\n\tint sid;\n\tchar name[200];\n\tint age;\n}; //分号不能省\n//定义了一个新的数据类型，叫struct Student，里面有三个成员sid，name，age\nint main(void)\n{\n\tstruct Student st = {1000, \"zhangsan\", 20};\n\t//用struct Student数据类型定义了一个名为st的新变量。\n\tprintf(\"%d  %s  %d\\n\", st.sid, st.name, st.age);\n\n\tst.sid = 99;\n\t//st.name = \"lisi\";  //error，只有java能这样写\n\tstrcpy(st.name, \"lisi\");\n\tst.age = 22;\n\tprintf(\"%d  %s  %d\\n\", st.sid, st.name, st.age);\n\n\t//printf(\"%d %s %d\\n\", st);  //error\n\treturn 0;\n}    \t\n```\n\n2.5 动态内存分配和释放\n\n```\n使用malloc分配的就是动态内存，不使用的就是静态内存。动态分配的内存一定要手动释放，否则造成内存泄漏。\n```\n\n动态内存的分配和释放\n\n```\nint *p\t= (int *) malloc(int len)\n1、 malloc只有一个int型的形参，表示要求系统分配的字节数；\n2、 malloc 函数的功能是请求系统 len 个字节的空间，如果请求分配成功，返回第一个字节的地址，如果分配不成功，则返回NULL\n3、 malloc 函数有且只能第一个字节的地址，所以我们需要把这个无任何实际意义的第一个字节的地址（俗称干地址）转化为第一个有实际意义的地址，因此malloc前面必须加（数据类型 *），表示把这个无实际意义的第一个字节的地址转化为相应类型的地址：如 int p* = (int*)malloc(50)\t表示将系统分配好的50个字节的第一个字节的地址转化为int*类型，更准确的说是吧第一个字节的地址转化为4个字节的地址，这样p就指向了第一个的四个字节，P+1 指向第2个的四个字节，\tp+i 指向第i个的四个字节。p[0]就是第一个元素，p[i]就是i+1个元素。\n再比如 double p* = (double *)malloc(80)表示将系统分配好的80个字节的地址转化为double *类型的地址，更准确的说把第一个地址转化为8个字节的地址，这样p就指向第一个8个字节，p[0]就是第一个元素，p[i]就是i+1个元素。\n```\n\n```\nfree(p)释放p所指向的内存，而不是释放p本身所占用的内存。\n```\n\n```c\n# include <stdio.h>\n# include <malloc.h>\n\nint main(void)\n{\n\tint a[5] = {4, 10, 2, 8, 6};//静态分配内存\n\n//用指针动态分配内存，模拟数组\t\n\tint len;\n\tprintf(\"请输入你需要分配的数组的长度: len = \");\n\tscanf(\"%d\", &len);\n\tint * pArr = (int *)malloc(sizeof(int) * len);\n//sizeof(int)是整型的字节数，若len=5，则(sizeof(int) * len)=20，20表示malloc函数请求操作系统为程序分配20字节的空间。(int *)是强制转换，无论一个变量占几个字节，malloc函数只能返回第一个字节地址，这个地址是无意义地址（干地址），所以前面需要强制转换，告诉编译器第一个地址是什么类型（int or double……）的地址\n//\t*pArr = 4;  //类似于 a[0] = 4; \n//\tpArr[1] = 10; //类似于a[1] = 10;\n//\tprintf(\"%d %d\\n\", *pArr, pArr[1]);\n\n\t//我们可以把pArr当做一个普通数组来使用\n\tfor (int i=0; i<len; ++i)\n\t\tscanf(\"%d\", &pArr[i]);\n\n\tfor (i=0; i<len; ++i)\n\t\tprintf(\"%d\\n\", *(pArr+i));\n\n\t\n\tfree(pArr);  //把pArr所代表的动态分配的20个字节的内存释放\n\n\treturn 0;\n}\n```\n\n```\n指针的指针的使用 2) 动态内存分配与自动变量的内存分配。\n动态分配的内存必须调用free()函数才能释放，而自动变量一旦跳出它的代码作用范围，就会由编译器自动释放掉。\n让我们先看：\nA) 选项无论fun()中p的值如何变化，都不会影响到主函数中p的值，因为它是值传递\nB) 选项倒是把p的地址&p传递给了fun()函数，但遗憾的是，由于s是个自动变量，当推出fun()函数后，s变量所占内存单元会被会被释放掉，此时主函数中的p还是没法指向一个合法的int型单元\nC) 选项fun()的形参 int **p;表明p是个指向指针变量的指针变量，即是个指针的指针。 而主函数中的 int *p; 表明p只是个指针变量，但&p则指向了p，&p也是个指向指针变量p的指针变量，实参和形参类型一致。 fun()的功能是使实参p指向了一个int型变量， 又由于该int型变量是由malloc()动态分配的，所以推出fun()函数并不会影响实参p的指向， 故C是对\nD) 选项犯了和A同样的错误。 真想不到二C还会考到这个知识，哈哈!\n```\n\n```c\n# include <stdio.h>\n# include <malloc.h>\n\nstruct Student\n{\n\tint sid;\n\tint age;\n};\n\nstruct Student * CreateStudent(void);\nvoid ShowStudent(struct Student *);\n\nint main(void)\n{\n\tstruct Student * ps;\n\n\tps = CreateStudent();\n\tShowStudent(ps);\n\n\treturn 0;\n}\n\nvoid ShowStudent(struct Student * pst)\n{\n\tprintf(\"%d %d\\n\", pst->sid, pst->age);\n}\n\nstruct Student * CreateStudent(void)\n{\n\tstruct Student * p = (struct Student *)malloc(sizeof(struct Student));\n\tp->sid = 99;\n\tp->age = 88;\n\treturn p;\n}\n//输出99 88\n```\n\n","tags":["技术"],"categories":["算法"]},{"title":"自适应和响应式","url":"/2022/04/12/自适应和响应式/","content":"\n# 不同点：\n\n比较直观的不同是：自适应：需要开发多套界面；响应式开发一套界面\n自适应设计 通过检测视口分辨率，来判断当前访问的设备是：pc端、平板、手机，从而请求服务层，返回不同的页面；响应式设计通过检测视口分辨率，针对不同客户端在客户端做代码处理，来展现不同的布局和内容。\n自适应 对页面做的屏幕适配是在一定范围：比如pc端（>1024）一套适配,平板（768-1024）一套适配，手机端（<768）一套适配;响应式一套页面全部适配。（可以想象：响应式设计要考虑的内容要比自适应设计复杂的多）\n\n# 共同点：\n\n两者都是优化适应互联网中越来越分化的视口浏览体验，而出现的为视口提供更好的体验的技术。用技术来使页面适应不同分辨率的视口的设计。\n\n\n\n\n\n链接https://blog.csdn.net/li_li_lin/article/details/80675092\n","tags":["web前端"],"categories":["自适应和响应式"]},{"title":"浏览器的工作原理","url":"/2022/04/12/浏览器的工作原理/","content":"\n# 浏览器的加载原理\n\n 要理解浏览器的工作原理首先要对浏览器有一个初步的认识（几个主流的浏览器：IE、Chrome、Firefox、afari、Opera），浏览器中最核心的部分是渲染引擎（Rendering Engine），也就是所谓的“浏览器内核”\n\n　　其实浏览器的内核除渲染引擎外还包括JS引擎，前者决定了浏览器如何显示网页的内容以及页面的格式信息，主要负责对网页愈发的解释并渲染；后者则是对JavaScript进行解释、编译和执行，从而使网页达到一些动态效果\n\n　　最开始的时候二者并没有很明确的区分，只不过随着JS引擎越来越独立，后来提起内核我们就更倾向于指的是渲染引擎\n\n# 浏览器的工作流程\n\n当我们在浏览器地址栏中敲如url回车后浏览器工作流程大致是这样的：浏览器开启网络请求线程，向服务器发送完整的http请求，再由服务器把数据返回到浏览器中，期间经历了一系列流程如：DNS查询、TCP/IP请求构建、五层因特网网络协议等\n\n　　浏览器在接收到内容后首先会根据文件的编码格式如UTF-8将字节流转为字符流，然后语法解析器根据标签的开始、标签的结束、属性等将html解析成Token（比如<p class='test' >helloworld</p> 就可以拆分为<p标签的开始、class='test'属性、</p>标签的结束）接下来就会把这些词构成一颗DOM树\n\n　　浏览器也会将CSS样式解析成CSSOM树，之后会根据样式的Selector将CSSOM和DOM合并成为Render Tree，最后浏览器会根据Render Tree 计算布局与元素的大小并绘制整个页面。\n\n# 浏览器是多进程的\n\n浏览器是多进程的，有一个主控进程，以及每一个tab页面都会新开一个进程（某些情况下多个tab会合并进程）\n\n进程可能包括主控进程，插件进程，GPU，tab页（浏览器内核）等。\n\n- Browser进程：浏览器的主进程（负责协调、主控），只有一个\n- 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建\n- GPU进程：最多一个，用于3D绘制\n- 浏览器渲染进程（内核）：默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白tab会合并成一个进程\n\n# 浏览器渲染引擎是多线程的\n\n- js引擎线程\n  - JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序\n- GPU渲染线程\n  - 注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。\n- 定时器线程\n  - 传说中的setInterval与setTimeout所在线程\n  - 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）\n  - 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）\n  - 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。\n- 事件触发线程\n- 异步http请求线程\n  - 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求\n  - 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。\n\n# 回流与重绘\n\n## 回流\n\n　回流是指窗口尺寸被修改、发生滚动操作，或者元素位置相关属性被更新时会触发布局过程，在布局过程中要计算所有元素的位置信息。由于HTML使用的是流式布局，如果页面中的一个元素的尺寸发生了变化，则其后续的元素位置都要跟着发生变化，也就是重新进行流式布局的过程，所以被称之为回流\n\n触发回流包括如下操作：\n\n　　1、DOM元素的几何属性变化\n\n　　2、DOM树的结构变化\n\n​    \t3、改变元素的一些样式\n\n　　4、调整浏览器窗口大小\n\n　　5、获取下列属性\n\n触发回流一定会触发后续的重绘操作，而且对一个元素的回流，可能会影响到父级元素。比如子元素浮动后，父元素会出现高度塌陷的情况。所以，性能优化的重点在于尽量只触发小规模的重绘，尽量不触发回流\n\n## 重绘\n\n　重绘是指当与视觉相关的样式属性值被更新时会触发绘制过程，在绘制过程中要重新计算元素的视觉信息，使元素呈现新的外观由于元素的重绘repaint只发生在渲染层 render layer上。所以，如果要改变元素的视觉属性，最好让该元素成为一个独立的渲染层render layer\n\n　　下面以元素显示为例，进行说明。实现元素显示隐藏的方式有很多\n\n　　display: none/block，会引起回流，从而引起重绘，性能较差\n\n　　visibility: visibile/hidden，只引起重绘，但由于没有成为一个独立的渲染层，会引起整个页面（或当前渲染层）的重绘，性能较好\n\n　　opacity: 0/1，opacity小于1时，会产生render layer。所以opacity在0、1的变化中，引起了render layer的生成和销毁，因此，也会引起回流，从而引起重绘，性能较差。如果opacity: 0/0.9，则只会引起重绘\n\n　　如果对一个元素使用硬件加速渲染，如具有CSS 3D属性，则不会进行重绘和回流。但如果使用硬件渲染的元素过多，会造成GPU的传输压力\n\n## 性能优化\n\n下面列举一些减少回流次数的方法\n\n　　1、不要一条一条地修改DOM样式，而是修改className或者修改style.cssText\n\n　　2、在内存中多次操作节点，完成后再添加到文档中去\n\n　　3、对于一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示\n\n　　4、在需要经常获取那些引起浏览器回流的属性值时，要缓存到变量中\n\n　　5、不要使用table布局，因为一个小改动可能会造成整个table重新布局。而且table渲染通常要3倍于同等元素时间\n\n　　此外，将需要多次重绘的元素独立为render layer渲染层，如设置absolute，可以减少重绘范围；对于一些进行动画的元素，可以进行硬件渲染，从而避免重绘和回流\n\n# 参考文档\n\nhttps://www.cnblogs.com/Shellcoochi/p/11752906.html\n\nhttps://www.cnblogs.com/xiaohuochai/p/9174471.html\n\nhttps://www.jianshu.com/p/1e455a9226ce\n\nhttps://www.jianshu.com/p/05606b0b4eb1\n\nhttp://www.ruanyifeng.com/blog/2014/10/event-loop.html\n","tags":["web前端"],"categories":["浏览器的加载原理"]},{"title":"舌前音节练习","url":"/2022/04/10/舌前音节练习/","content":"\n\n\n![音节练习1](https://cdn.jsdelivr.net/gh/pyofgavin/image@master/我的资源/音节练习1.7ia15qrwpos0.PNG)\n\n![音节练习2](https://cdn.jsdelivr.net/gh/pyofgavin/image@master/我的资源/音节练习2.5lxbghpdpf00.PNG)\n\n![音节练习3](https://cdn.jsdelivr.net/gh/pyofgavin/image@master/我的资源/音节练习3.ipete32rkl4.PNG)\n\n![音节练习4](https://cdn.jsdelivr.net/gh/pyofgavin/image@master/我的资源/音节练习4.5yao5kutpw00.PNG)\n\n![音节练习5](https://cdn.jsdelivr.net/gh/pyofgavin/image@master/我的资源/音节练习5.604g0mhp7f80.PNG)\n","tags":["音节练习"],"categories":["舌前舍后"]},{"title":"一文搞懂js预编译","url":"/2022/03/22/一文搞懂js预编译/","content":"\n原文链接：https://zhuanlan.zhihu.com/p/483283900\n\n# 预编译\n\n```js\n首先创建了AO对象，AO={}，那么，它具体做了哪些事情呢？\n```\n\n第一步，寻找函数的形参和变量声明\n\n第二步：把实参赋值给形参\n\n第三步：寻找函数声明，赋值函数体\n\n第四步：执行函数\n\n# 作用域\n\nscope是一个属性 保存着作用域链\n\n\n\n# 闭包\n\n什么是闭包？\n\n当内部函数被返回并保存的时候，一定会产生闭包。闭包的产生导致原来的作用域链不释放，过度的闭包会导致加载过慢，造成内存泄漏，解决内存泄漏的方法就是把函数设置为空。\n\n闭包产生的原因用一句话总结就是外部函数的作用域链未释放\n\n```js\n//例子\nfunction fun1(){\n    function fun2(){\n       console.log(a)\n    }\n    var a = 1;\n    return fun2;\n}\nvar test = fun1()\ntest()// 打印出 1\n```\n\n","tags":["预编译"],"categories":["js"]},{"title":"沉浸式状态栏","url":"/2022/03/08/沉浸式状态栏/","content":"\n**沉浸式状态栏**\n\n​\t改变状态栏背景颜色\n\n​\t该方法是全局修改\n\n什么是沉浸式状态栏？\n\n1. 打开menifest.json文件  plus 增加一个plus属性\n\n```json\n\"plus\":{\n    \"statusbar\":{\n        \"immersed\":true\n    }\n}\n```\n\n2.修改meta  ==> viewport-fit=cover\n\n```js\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover\" />\n```\n\n\n\n\n\n"},{"title":"前后端数据库关系","url":"/2022/03/07/前后端数据库关系/","content":"\n**web页面-服务器-数据库之间的关系**\n\n```\n什么是HTTP请求？\n```\n\n```\nDNS解析，\n```\n\n```\n建立TCP链接，\n```\n\n```\n然后发起HTTP请求\n```\n\n```\n服务器端解析收到HTTP请求，进行处理，返回数据\n```\n\n```\n客户端接受到返回的数据，处理数据（例如渲染页面）\n```\n\n","tags":["web前端"],"categories":["web前端"]},{"title":"git版本管理","url":"/2022/03/07/git版本管理/","content":"\n```js\ngit status 查看状态\n```\n\n```js\ngit checkout -b login 创建分支\n```\n\n```js\ngit branch 查看目前在哪一个分支\n```\n\n```js\ngit checkout master 切换分支\n```\n\n```js\ngit merge login 合并代码\n```\n\n```\ngit fetch 从远程分支上拉取代码\n```\n\n```\ngit pull = git fetch + git merge\n```\n\n```\ngit push origin master:dev 拉取远程master分支代码并与本地分支dev合并\n```\n\n```js\ngit push 把本地最新的master代码推送到码云中\n```\n\n```js\ngit push -u origin login 第一次推送login，创建 login分支\n```\n\n```js\ngit status 查看当前项目中源代码的状态  包括修改的和新增的\n```\n\n```js\ngit add . 把代码添加到本地的暂存区\n```\n\n```js\ngit commit -m 把暂存区的代码提交到本地的仓库中\n```\n\ngit是什么？版本管理工具\n\ngit的下载和安装：\n\ngit基本工作流程：git仓库  暂存区  工作目录\n\n![image-20220223010519082](https://cdn.jsdelivr.net/gh/pyofgavin/image@master/我的资源/image-20220223010519082.2vnpbqw5zx60.png)\n\ngit使用前配置：告诉git你是谁  提交人的信息\n\n```\n提交人的姓名： git config --global user.name 提交人的姓名\n```\n\n```\n提交人的邮箱： git config --global user.email 提交人的邮箱\n```\n\n```\n查看当前的配置：git config --list \n```\n\ngit的提交步骤：\n\n```\n1. git init 初始化git仓库\n2. git status 查看暂存区的文件状态\n3. git add 文件列表  追踪状态 把没有被git管理到的文件添加到暂存区\n4. git commit -m 提交信息  向仓库中提交代码\n5. git log 查看提交的历史记录\n```\n\ngit 的撤销\n\n```\ngit checkout 文件 用暂存区的文件覆盖工作目录中的文件\n```\n\n```js\ngit rm --cached 文件 将文件从暂存区删除\n```\n\n```\ngit reset --hard commitID   将git仓库中指定的更新记录恢复出来 并覆盖暂存区和工作目录 \n```\n\ngit分支\n\n```\n在不同的分支上专注做不同的事情\nmaster 是主分支 除主分支之外 还有开发分支 和 功能分支\n具体的功能在功能分支上开发 功能分支上开发完之后再合并到开发分支 \n在开发分支上测试没有问题之后，再将开发分支合并到主分支上面\n```\n\n```\ngit branch 查看分支\ngit branch 分支名称 创建分支 git branch develop \ngit checkout develop 切换分支 注意：\ngit merge 分支名称 合并分支\ngit branch -d 分支名称 删除分支（如果分支没有合并 是不允许删除的，可以使用 -D强制删除命令）在其他分支中删除这个分支，不允许在本分支中删除本分支\n```\n\n暂时保存更改：\n\n在git中 可以暂时提取分支上所有的改动并存储，让开发人员得到一个干净的工作副本，临时转向其他工作。\n\nnothing to commit  working tree clean\n\n```\n存储临时改动:git stash \n恢复改动： git stash pop\n```\n\nGithub注册 多人协作开发  公共仓库\n\n将本地仓库推送到远程仓库：\n\n```\ngit push 远程仓库地址 分支名称\n```\n\n为远程仓库地址起一个别名\n\n```\ngit remote add origin 仓库地址\ngit push origin 分支名称  （origin就是别名）\n```\n\n```\ngit push -u origin master(git会记住远程仓库的别名，下一次推送直接 git push 就可以了)\n```\n\n克隆仓库\n\n```\ngit clone 仓库地址\n```\n\n删除本地仓库\n\n```\ngit fetch -p\n```\n\n删除远程分支并不会删除本地分支\n\n```\ngit push origin --delete [branchname]\n```\n\n","tags":["web前端"],"categories":["web前端"]},{"title":"node搭建服务器","url":"/2022/03/07/node搭建服务器/","content":"\n**搭建node服务器基本步骤**\n1.初始化node目录 `npm init -y`\n2.安装必要的依赖项 `npm install express --save`\n3.创建服务端的入口程序文件   `index.js`\n4.编写服务器端程序\n5.启动服务器 `node index.js`\n6.解决跨域问题 `npm install cors --save`\n\n7.服务器代码段如下\n\n```js\nconst express = require('express');//第一步 引入 express模块\nconst app = express();  //第二步： 创建一个app应用\n\napp.listen(9010,()=>{//监听9010端口app应用\n    console.log('服务器已启用');\n    \n});\n\napp.get(\"/\",(req,res)=>{\n    res.send(\"根目录正常\")\n});//第四步：创建一个根目录  /表示根目录\n\n\napp.get(\"/api/users\",(req,res)=>{//第五部 创建一个/api/users路径 并向客户端发送一段json数据\n    const users = [\n        {id:\"admin\",name:\"管理员\"},\n        {id:\"zxm\",name:\"邢建杰\"},\n        {id:\"currry\",name:\"库里\"},\n    ];\n    res.json(users);\n});\n```\n","tags":["web服务器"],"categories":["web服务器"]},{"title":"mysql","url":"/2022/03/07/mysql/","content":"\n<div align=\"center\"> <font size = '70' color=blue>结构化查询语言 </font></div>\n\n# MySQL数据库\n\n## 什么是计算机语言\n\n\n- 机器语言：\n  01010101110000111\n\n- 汇编语言\n\n\n- 高级语言\n  C python JAva SQL C# php C++ JS\n\n## SQL的概述\n\n结构化查询语言，是一种操作数据库的语言，SQL适用所有关系型数据库。例如：MySQL、Oracle、SQLServer\n\n## SQL的特点\n\n- 综合统一性\n\n- 非过程语言\n\n- 语言简介\n\n- 以一种语法结构提供两种使用方式：SQL+ JAVA\n\n  ### SQL语法特点：\n\n- 对关键字的大小写不敏感\n\n- 单行注释 --空格结束  #后面可不加空格\n\n  ### 数据库\n\n- 数据库是一个以某种组织方式存储在磁盘上数据的集合。\n\n  #### 数据库的应用\n\n- 管理系统、应用软件\n\n  #### 数据库的分类\n\n- 关系型数据库\n\n  ```\n  Oracle甲骨文\n  MySQL数据库（最流行的中型数据库）\n  ```\n\n- 非关系型数据库NoSQL\n\n  ```\n  Redis\n  MongoDB\n  Elasticsearch\n  Cassandra\n  Hbase 列式数据库 分布式数据库\n  ```\n\n  关系型数据库的组成 \n\n  ```\n  数据库 --> 表\n  ```\n\n## MySQL的特点\n\n- 支持多系统\n- 支持多线程\n- 为多种语言提供API\n- 开源\n\n## MySQL 数据库基本操作-DDL\n\n```sql\n数据定义语言：不涉及数据的操作\n查看所有的数据库： show databases\n创建数据库： create database[if not exists] mydatabase[charset=utf-8]\n切换数据库：use mydatabase\n删除数据库： drop database[if exists] mydb1\n修改数据库编码：alter database mydb1 character set utf-8\n查看当前数据库所有的表 show tables\n删除表 drop tables\n查看指定表的创建语句 show create table student\n查看表结构 desc table\n```\n\n\n\n## MySQL 数据库基本操作-DML\n\n <font color='red' size = '5'> 数据的插入 `insert`</font>\n\n```js\ninsert into 表（列1，列2，列3...） values（值1，值2，值3...）//向表中插入某些列\n\ninsert into 表 values（值1，值2，值3...）//向表中插入所有列\n\ninsert into 表 vaues（...），（...），（...）；一次性插入多行,每一行之间逗号分开；\n```\n\n <font color='red' size = '5'>数据的删除  `delete`</font>\n\n```sql\ndelete from 表名 where 条件\n\n\ntruncate table 表名\n\ntruncate 表名  //清空表数据\n\n```\n\n <font color='red' size = '5'> 数据的更新 `update`</font>\n\n```sql\nupdate 表名 set 字段名=值，字段名=值...；//将所有的行修改\n\nupdate 表名 set 字段名=值... where 条件；//修改满足条件的行\n\nupdate student set address where id = 1004；\n\n```\n\n## MYSQL的约束\n\n<font color=red>主键约束</font>&ensp; &ensp;&ensp;&ensp;<font color=blue> primary key 简称PK</font> 主键约束不允许重复，唯一标识，相当于身份证号，方便查找，分为<font color=red>联合主键</font> 和<font color=red>单列主键</font>\n\n```js\n方法1： <字段名><数据类型> primary key\n```\n\n<font color=red>自增长约束</font>&ensp;&ensp;&ensp;<font color=blue> primary key 简称AI</font>\n<font color=red>非空约束</font>&ensp;&ensp;&ensp;<font color=blue>not null 简称NN</font>\n<font color=red>唯一性约束</font>&ensp;&ensp;&ensp;<font color=blue> unique简称UN</font>\n<font color=red>默认约束</font>&ensp;&ensp;&ensp;<font color=blue> primary key 简称PK</font>\n<font color=red> 零填充约束</font>&ensp;&ensp;&ensp;<font color=blue> primary key 简称PK</font>\n<font color=red>外键约束</font>&ensp;&ensp;&ensp;<font color=blue> primary key 简称FK</font>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["数据库查询语言"],"categories":["数据库"]},{"title":"hexo使用方式","url":"/2022/03/07/flex布局/","content":"\nflex布局\n\n```css\ndisplay:flex\n```\n\nflex属性：\n\n```css\nflex-direction: 属性定义容器要在哪个方向上堆叠 flex 项目\nflex-direction: column;垂直堆叠(从上到下)\nflex-direction: column-reverse;(从下到上)\nflex-direction: row;(从左到右)\nflex-direction: row-reverse;(从左到右)\n```\n\n```css\nflex-wrap 属性规定是否应该对 flex 项目换行\nflex-wrap: wrap;规定 flex 项目将在必要时进行换行：\nflex-wrap: nowrap;值规定将不对 flex 项目换行（默认）：\n```\n\n```css\nflex-flow 属性是用于同时设置 flex-direction 和 flex-wrap 属性的简写属性\nflex-flow: row wrap;\n```\n\n```css\njustify-content\njustify-content: center; 项目在容器的水平方向居中对齐\njustify-content: flex-start;项目在容器的开头对齐（默认)\njustify-content: flex-end;\njustify-content: space-around;显示行之前、之间和之后带有空格的 flex 项目\njustify-content: space-between;值显示行之间有空格的 flex 项目：\n```\n\n```css\nalign-items 属性用于垂直对齐 flex 项目\nalign-items: center; 项目在容器垂直方向上居中对齐：\nalign-items: flex-start; 顶部对齐\nalign-items: flex-end; 底部对齐\nalign-items: stretch; 垂直方向上拉伸项目 亦填充容器\nalign-items: baseline; 基线对齐 \n```\n\n```\nalign-content  属性用于对齐弹性线\nalign-content: space-between; 弹性线之间有相等的间距\nalign-content: space-around; 弹性线在其之前、之间和之后带有空格\nalign-content: center; 容器中间显示弹性线：\nalign-content: flex-start; 容器上部显示弹性线\nalign-content: flex-end; 容器下部显示弹性线\n```\n\n完美的居中\n\n```css\njustify-content: center;\nalign-items: center;\n```\n\ncss文本效果\n\ncss文本溢出 整字换行 换行规则及书写模式\n\ntext-overflow 文字溢出\n\nword-wrap\n\nword-break\n\n```css\n white-space: nowrap; 规定段落中的文本不进行换行\n```\n\n```\nword-break: keep-all; 将连字符打断：\nword-break: break-all; 任何字符处中断：\nword-wrap: break-word;   允许长单词被打断并换行到下一行：\n```\n\nwriting-mode\n\n```css\noverflow: hidden; 溢出隐藏\ntext-overflow: ellipsis;  ...代替\noverflow: visible;隐藏元素可见\n```\n\n单行文本超出隐藏\n\n```css\nwhite-space: nowrap;\noverflow: hidden;\ntext-overflow: ellipsis;\n```\n\n","tags":["web前端"],"categories":["web前端"]},{"title":"hexo 发布博客","url":"/2022/03/07/hexo使用方式/","content":"\n```js\nhexo clean\n```\n\n```\nhexo g 生成静态页面\n```\n\n```\nhexo s 启动服务 ==> 部署\n```\n\n```\nhexo d 同步个人博客 ==> 发布\n```\n\n```\nhexo new 文件名  生成 md文件\n```\n\n","tags":["个人博客"],"categories":["博客搭建"]},{"title":"移动端","url":"/2022/03/03/移动端app/","content":"\n# 移动端APP\n\n## reset 和 Normalize\n\n```js\nreset 重置样式\nnormalize:解决浏览器的兼容问题。\n```\n\n## 布局单位\n\n```js\npx 固定单位\nem|rem 相对单位\n\t区别:em相对于父元素\n    \trem相对于根元素 html \n浏览器字体默认高度 16px  移动端用的最多的额是rem\n```\n\n### 自适应布局\n\n```js\n自适应布局:随着设备的大小。自动改变盒子的宽高。\n实现:拉钩 + 京东 + 淘宝 \n引入js文件 flexible.js \n```\n\n```js\niphone6:375px、667px  html的font-size:37.5px  100px ==> 100/37.5 rem\n```\n\n### 面试题：无宽高如何居中\n\n```\n1.弹性盒模型\n\tdisplay: flex;\n    justify-content: center;\n    align-items: center;\n2.transform\n\t父元素: position:relative\n\t子元素:position: absolute;\n   \t\t top: 50%;\n   \t\t left: 50%;\n    \t transform: translate(-50%,-50%);\n3.网格布局：display:grid    \t \n```\n\n# 移动端兼容\n\n## 移动端300ms延迟\n\n```js\n解决方法:\n\t禁用缩放 <meta name = \"viewport\" content=\"user-scalable=no\" > \n\t插件 fastclick\n    // 安装\n\tnpm install fastclick -S\n\t// 引入\n\timport FastClick from 'fastclick'\n\t// 使用\n    if ('addEventListener' in document) {\n        document.addEventListener('DOMContentLoaded', function() {\n            FastClick.attach(document.body);\n        }, false);\n    }\n\n```\n\n## touch事件与穿透问题\n\n```js\n解决方法: 阻止默认行为\n\t\tfastclick插件\n```\n\n# 移动端性能优化\n\n## 懒加载以及原理\n\n```js\n//什么是懒加载？数据很多，用户并不需全部数据，只需要部分数据，此时就需要懒加载\n//原理:利用标签的自定义属性 data-xxx 来保存图片的路径，将data-xxx赋值给src就可以实现按需加载。\n//实现的方式：lazyload\n//引入文件\n<script src=\"lazyload.min.js\"></script>\n//使用\n$(\".lazy\").lazyload();\n```\n\n懒加载文档：https://github.com/jieyou/lazyload\n\n## 下拉刷新 和 上拉加载\n\n```js\n插件：https://www.jq22.com/jquery-info6960\n```\n\n​\t插件：https://www.jq22.com/jquery-info6960\n\n","tags":["移动端app"],"categories":["web前端"]},{"title":"在chrom中用键盘快速打开书签页的方法","url":"/2022/03/03/在chrom中用键盘快速打开书签页的方法/","content":"\n在chrom浏览器中仅用键盘快速打开书签页的方式\n\n第一步：打开书签页管理器 ctrl+shift+O\n\n第二部：在聚焦框中输入要搜索的书签页\n\n第三步：找到之后，连续按Tab键，使光标开始移动\n\n第四部：光标移动到想要打开的书签页时 按一下空格键 ，然后再按一下Enter键就可以打开新的书签页了\n\n![image](https://cdn.jsdelivr.net/gh/pyofgavin/image@master/我的资源/image.2f0ufnp96hgk.png)\n\n","tags":["奇思妙想"],"categories":["生活"]},{"title":"前端面试","url":"/2022/03/03/前端面试高频题/","content":"\n\n\n一、**HTML**\n\n1、行内有哪些元素?块内有哪些元素？他们之间的转化？\n\n```js\n\t行内元素：  span a \n​\t块级元素：div footer header section p h1-h6\n​\t空元素：hr br \n​\t转换：display: block  块级元素\n​\t\t          inline  行内元素\n​\t\t          inline-block 行级块元素\n```\n\n2、 页面导入样式 使用link 和 @import有什么区别\n\n​\t区别一： link 兼容性更好\n\n​\t区别二：加载的顺序不一样，先加载link 后加载import\n\n​\t区别三：link是一个标签\n\n拓展题：href 和 src 的区别: \n\n​\t\t\thref 用来引入超文本，link 和a 标签使用   浏览器运行到href的时候 不会暂停对文档的处理\n\n​\t\t\tsrc 表示引用资源 在script img标签中使用，指向外部资源的位置，浏览器运行到src的时候 会暂停其他资源的下载和处理\n\n3、title 与 h1的区别  b与strong的区别 i与 em的区别\n\n```\ntitle与 h1的区别：\n```\n\ntitle：概括了网站的信息 可以告诉搜索引擎和用户关于网站的内容是什么 \n\nh1 文章的标题 告诉搜索引擎内容是什么\n\n区别： title 显示在网页标题上 h1 显示在页面上  title比h1更重要 ==> seo的理解\n\n```\nstrong 与 b \n```\n\nb标签：实体标签， 给文字加粗\n\nstrong： 逻辑标签，表示标签内字符比较重要 起强调\n\n```\ni 与 em的区别\n```\n\ni ：实体标签 文字倾斜\n\nem：表示标签内字符重要 用来做强调\n\n4、img标签中 title 与 alt 的区别：\n\n```\n1、表现形式： title 鼠标移到图片的提示   alt 图片加载不出来的时候显示\n2、在SEO层面上：在写img标签的时候 为了增加 seo的效果 加入alt属性来描述 这张图片的内容\n```\n\n5、 png|jpg|gif|webg的格式 分别什么时候用?\n\n```js\npng:无损压缩，尺寸体积 比jpg/jpeg的 大，适合做小图标\njpg：采用 压缩算法 有点失真 适合做中大图\ngif：动图\nwebg：同时支持有损和无损压缩 相同质量的图片 webg具有更好的体积 兼容性不是特别好\n```\n\n二、**CSS**\n\n1、css盒模型有哪些？：标准盒子模型     IE盒子模型\n\n```js\n区别：\n​\t\t标准盒模型：margin、border、padding、content\n​\t\tIE盒模型：margin content( border、padding )\n如何转换盒子模型：box-sizing: content-box(标准)、border-box（IE）\n```\n\n2、line-height height 的区别\n\n```js\nline是一个死值、就是盒子的高度 line-height 是一行文字的高度 \n```\n\n3、CSS选择符有哪些？\n\n```\n通配符（*）\nid选择器（.）\n类选择器（#）\n标签选择器（div p  ul li ）\n相邻选择器（+）\n子元素选择器（>）\n属性选择器（div[属性名]）\n后代选择器 + （除了第一个元素外 ）\n```\n\n4、CSS属性哪些可以继承？\n\n```js\n文字系列可以继承\npadding margin 不可以继承！！\n```\n\n5、CSS权重计算？\n\n```\n内联样式： 权重值1000\nid选择器  权重值100\nclass选择器  伪类 权重值 10\n标签 & 伪元素 权重值 1\n通配符 0\n!import >内联样式 > id > class > 标签 > 通配符\n```\n\n6、 CSS画一个三角形\n\n```js\n用 border (透明)\n\t  height: 0px;\n      width: 0px;\n      border-left: 100px solid #ccc;\n      border-right: 100px solid transparent;\n      border-top: 100px solid transparent;\n      border-bottom: 100px solid transparent;\n```\n\n7、一个盒子怎么居中（不给宽高）？flex主轴、侧轴\n\n```html\ndispaly:flex\njustify-content:center（水平）\nalign-items:center(垂直)\n\n\nposition: absolute;\nleft: 50%;\ntop: 50%;\ntransform: translate(-50%,-50%);\n\n\n元素添加绝对定位 上右下左的值 为0  margin:aoto\n\ntable属性\n父元素设置 disolay:table\n子元素：display:table-cell   vertical-align:middle  test-aligin:center\n```\n\n8、dispaly有哪些值？\n\nnone block inline-block inline \n\n*9、BFC的理解\n\n```js\nBFC就是页面一个隔离的独立容器 容器内的元素不会影响到外面的元素，格式化上下文\nBFC的原则：如果一个元素具有BFC 那么内部元素再怎么动 不会影响到 外面的元素\n如何触发BFC：\n\t\tfloat的值非none (会造成父元素的高度塌陷)\n\t\toverflow的值非visible （最常用） hidden（会把溢出的内容不显示）auto scroll\n\t\tdisplay的值为：inline-block  table-cell table(把原来元素转为行内块元素，高度依然胡塌陷) [flow-root]存在兼容性问题\n\t\tposition的值为：absolute fixed\nBFC应用的场景：\n\tmargin塌陷\n    清楚浮动\n```\n\n*10、清楚浮动有哪些方式：\n\n```\n1、触发BFC\n使用after伪类清楚浮动\n2、div:after{\n\tcontent:''\n\tdispaly:block\n\tclear:both\n}\n3、给父元素设置一个高 \n4、在父元素后面添加一个空标签  给该标签设置 clear:both\n```\n\n11、在网页中的应该使用奇数 还是 偶数的字体？（1%）\n\nUI出示意图 前端开发 ，方便开发 设计的时候都是偶数 偶数让文字在浏览器上表现更好看 UI设计都是偶数 布局 转化为px也好 方便一点\n\n*12、有几种定位（position） 分别根据什么进行定位？\n\n```\n默认：static 没有定位 \n\tfixed 固定定位 相对于浏览器窗口进行定位\n\trelative: 不脱离文档流 相对于自身进行定位 \n\tabsolute:脱离文档流 相对于第一个有relatived的父元素（子绝父相）\n\t\n```\n\n*13、双飞翼布局 左右200px 中间自适应\n\n```html\n<div class=\"center\">\n  <div class=\"main\">center</div>\n</div>\n<div class=\"left\">\n  left\n</div>\n<div class=\"right\">\nright\n</div>\n\n<style>\n    .left{\n      width: 200px;\n      height: 500px;\n      background-color: #224;\n      float: left;\n      margin-left: -100%;\n    }\n    .right{\n      width:200px;\n      height: 500px;\n      background-color: #453;\n      margin-left: -200px;\n      float: left;\n    }\n    .center{    \n      width: 100%;\n      background-color: antiquewhite;\n      height: 500px;\n      float: left;\n    }\n    .main{\n      padding:0px 200px ;\n    }\n  </style>\n```\n\n圣杯模式和双飞翼模式的区别？\n\n作用：这两种布局时解决同一个问题：两边宽度固定，中间自适应的三栏布局，要求先加载中间内容\n\n区别：\n\n​\t\t圣杯布局：不让中间的内容被挡住，把中间的div设置左右的padding后，再把左右两个div用相对定位的left和right,把中间内容给显示出来\n\n​\t\t双飞翼布局：为了不让中间内容被挡住，需要再中间部分创建一个子元素来存放内容，再次修改div的位置，两边设置margin-宽度值\n\n```html\n<div class=\"header\">\n    <div class=\"main\">\n        <div class=\"mid\">\n            中间\n        </div>\n        <div class=\"left\">\n            左\n        </div>\n        <div clss=\"right\">\n            右\n        </div>\n    </div>\n</div>    \n    <style>\n    \n    </style>\n```\n\n14、reset.css 重置样式库  normalize.css  解决跨浏览器的一致性\n\n\n\n15、css雪碧图 精灵图  css spirit 把多个小图标合成一张大图片\n\n```html\n使用：background-position:-99px -34px\n优点：减少了http请求的次数、提高了性能\n缺点：不利于后期的维护\n```\n\n16、display:none  与 visibility:hidden\n\n```js\n1、占用位置的区别：\ndisplay:不占用位置  visibility占用位置 虽然不可见 但是元素的位置在那里 \n2、重绘和回流\nvisibility：hidden 、display:none 产生重绘\ndispaly:none 还产生了一次回流\n产生回流一定会造成重绘，但是重绘不一定造成回流\n回流：改变元素的位置 显示隐藏的元素\n重绘：样式改变 背景色\n```\n\n![image-20220219214842827](C:\\Users\\XINGJIANJIE\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220219214842827.png)\n\n17、opacity 和 rgba区别\n\n```\n1、opacity 取值范围 0到1之间 0表示完全透明  1表示不透明\n2、rgba：a表示透明度  0到1之间rgba()\n区别：opacity会继承父元素的opacity  而rgba设置的后代元素 不会继承不透明属性\n```\n\n**三、Javascript**\n\n预编译 --> 作用域 --> 闭包u\n\n1、延时加载js的机制\n\n```\nasync 与 defer 引入外部链接\nhtml解析 遇到js的引入代码时 会停止html 去加载js \n区别：defer：等html全部 加载完之后 才会顺次执行js文件\n\tasync:async 和 html同步执行的  不是顺次执行js脚本，谁先加载完谁执行\n```\n\n2、js数据类型有哪些？\n\n```js\n基本类型：string number boolean undefined null symbol bigint(有争议)\n引用类型：object （array fuction)\n引用类型转换： string与任何数据类型相加 都会转化为string\n\t\t\tnumber与任何不确定的数据类型相加 转化为NAN，NAN是一个数值类型 不是一个具体的数字\n            typeof(null) 是一个object\n            typeof(NAN) 是一个number\n```\n\n3、null 和undefined的区别?\n\n```js\n1、作者在设计js的时候 先设计的null \n2、null会被隐式的转化为0 很不容易发现错误\n3、现有null后有 undefined undefined 是为了填补之前的坑 typeof(Number（undefined)) = NAN\n具体区别：null是一个表示无的对象 转化数值时为0 undefined是一个基本数据类型 转化数值时是 NAN\n```\n\n4、== 和===的区别？\n\n```\n比较的判断：\n==相等：只比较值 包含隐式类型转化 \n===绝对相等：除了比较值 还比较数据类型\nnull == undefined  true\nstring == number 发生隐式类型转化 \nboolean == bumber  boolean为真时转化为1 为假时转化为 0 \n隐式转化是通过自动调用Object.ValueOf()函数 返回一个数值\n```\n\n5、JS微任务和宏任务？\n\n![image-20220219233832198](C:\\Users\\XINGJIANJIE\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220219233832198.png)\n\n![image-20220219233916897](C:\\Users\\XINGJIANJIE\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220219233916897.png)\n\n6、JS作用域(占80%)\n\n```js\n规则：除了函数之外，js没有块级作用域的\n     作用域链：内部可以访问外部的变量 外部访问不了内部的变量\n     \t\t如果内部有变量 优先访问内部的 内部没有 才会去找外部的 沿着作用域链去找\n     \t\t声名变量没有写 var去声名 是全局变量 window.b GA global Action\n     \t\tvar声名 会提升\n```\n\n注意两点：\n\n​\t\t<font color='red'>本层作用域有的话 先看本层的【注意变量提升!】</font>\n\n​\t\t<font color='red'>JS除了函数之外 不存在块级作用域的</font>\n\n​\t\t优先级：声明变量的优先级 > 声明普通函数 > 参数 > 变量提升\n\n​\t\t普通的声明函数 是不看写函数顺序的\n\n考题一：\t\n\n```\nfuction(){\n    var b = 1;\n    function a(){\n\t\tconsole.log(b) // undefined\n\t\tvar b = 2;\n\t\tconsole.log(b) //2\n    }\n    a();\n    console.log(b) // 1\n}\n```\n\n考题二：\n\n```js\nvar name = 'a';\n(function (){\n\tif(typeof name == 'undefined'){\n\t\tvar name = 'b';\n\t\tconsole.log('111' + name);// 111b 就算if语句不执行 var也会提升\n\t}else{\n\t\tconsole.log('222'+ name)\n\t}\n})()\n```\n\n考题三：\n\n```js\nfunction fun(a){\n    var a = 10;\n    function a(){}             var a = functio(){}//声明变量的形式\n    console.log(a);// 10       console.log(a);//function\n}\nfun(100);\n//声明变量的优先级 > 声明普通函数\n```\n\n考题四：\n\n```js\nfunction(){\n    a = 10; //a已经存在 再次复制操作而已\n    console.log(a); // 10\n    var a = 100;//提升\n     console.log(a); // 20\n}\n```\n\n\n\n7、JS对象\n\n```js\n1、对象是通过new操作出来的 所以对象之间不相等（除了引用外）\n2、对象注意：引用类型\n3、对象的key都是字符串类型；\n4、对象如何查找属性|方法\n先在对象本身找 ==> 在构造函数中找 ==> 对象原型中找 ==> 构造函数原型中找  ==> 对象上一层原型中找\nobj.__proto__ == Fun.prototype 对象的原型链= 构造方法的原型\nobj.constructor == Fun()\n```\n\n题目一：\n\n```js\nfunction Fun(){\n    this.a = '在Fun函数中添加的' //2\n}\nFun.prototype.a = '在Fun原型中添加的'//4\nlet obj = new Fun()\nobj.a = '对象本身中的方法'  //1\nobj.__proto__.a = '这是对象原型中添加的'//3\nObject.prototype.a ='这是在Object中添加的' //5\n```\n\n8、JS作用域 +this指向 +原型链的考题\n\n考题一：\n\n```js\nfunction Foo(){\n    getName = function(){console.log(1)}\n    return this;\n}\nFoo.getName = function(){console.log(2)}\nFoo.prototype.getName = function(){console.log(3)}\nvar getName = function(){console.log(4)}\nfunction getName(){ console.log(5)}\n\nFoo.getName(); //2\ngetName();//4\nFoo().getName();//相当于window.getName()此时 getName已经更新   getName = function(){console.log(1)}\ngetName(); //1\nnew Foo().getName(); //找getName()方法 对象上没有 构造方法中也没有 在构造方法中的原型中找到\n```\n\n考题二：（头条）\n\n```js\nvar 0 = {\n    a:10,\n    b:{\n        fn:function(){\n            console.log(this.a); //undefined\n            console.log(this); //b对象\n   \t\t }\n\t}\n}\no.b.fn(); //b执行的fn this 指向 b\n```\n\n考题三：(头条)\n\n```js\nwindow.name = 'ByteDance';\nfunction A(){\n    this.name = 123;\n}\nA.prototype.getA = function(){\n    console.log(this);\n    return this.name + 1;\n}\nlet a = new A();\nlet funcA = a.getA;\nfuncA(); //this 代表 window\n```\n\n考题四：(头条)\n\n```js\nvar length = 10;\nfunction fn(){\n    return this.length +1;\n}\nvar obj = {\n    length:5,\n    test1:functin(){\n    \treturn fn();\n}\n}\nobj.test2 = fn;\nconsole.log(obj.test1()); //11\nconsole.log(obj.test1() == obj.test2()); //false\nconsole.log(obj.test2() == fn());\n```\n\n9、JS判断是不是数组的方法\n\n```js\n方法一：Array.isArray(arr)\n方法二：instanceof (会找原型)可写可不写\n方法三：Object.prototype.toString.call(arr).indexOf('Array') \n方法四：Array.prototype.isPrototypeOf(arr)\n方式五：arr.constructor.toString().indexOf('Array') \nvar str = 'hiello';\nvar arr =  [1,2,3]\n\nconsole.log(Array.isArray(arr)) true\nconsole.log(arr instanceof Array)   true arr 是 Array构造出来的\n```\n\n10、数组的一些方法 slice 是干啥的  splice 面试之前过一遍所有的方法\n\n```js\nvar arr1 = ['1','2','3','4','5']\nslice是截取的  返回一个新的数组slice(3) slice(1,3) sclice(-3)\nsplice 增删替 会改变之前的数组  返回被删除的元素  splice(1,3)\n```\n\n***11、数组去重 \n\n```js\nnew Set(arr) 返回一个对象  \n把对象变成数组:\n\t\tArray.from(new Set(arr))\n\t\t[...new Set(arr)]\n```\n\n```JS\n函数的封装\nfunction unique(arr){\n    return [... new Set(arr)]\n}\n\nfunction unique(arr){\n    bar newArr = [];\n    for(var i = 0; i < arr.length; i ++){\n        if(newArr.indexOf(arr[i]) == -1){//newArr中没有这个元素\n        \t\tnewArr.push(arr[i])\n        }\n    }\n    return newArr;\n}\n\n\nfunction unique(arr){\n    arr = arr.sort();//先排序 \n    var newArr = [];\n     for(var i = 0; i < arr.length; i ++){\n        if(arr[i] !== arr[i-1]){//newArr中没有这个元素\n        \t\tnewArr.push(arr[i])\n        }\n    }\n    return newArr;\n}\n```\n\n12、找出多维数组最大值\n\n```js\nfunction findMax(arr){\n\tvar newArr = [];\n    arr.forEach((item)=>{\n        newArr.push(Math.max(... item))\n    })\n     return newArr;\n}\n```\n\n13、给字符串新增方法实现\n\n传给一个str前缀，返回带前缀的字符串\n\n```js\nString.prototype.addStr(str){\n    return srt+this\n}\n'world'.addStr(hello)  //返回 'helloworld'\n```\n\n14、找出字符串出现次数最多的字符\n\n```js\nvar obj = {};\nfor( var i = 0; i < str.length; i ++){\n    var char = str.charAt(i);\n    if(obj[char]){\n        obj[char]++; //每多出现一次 value+1\n    }else{\n        obj[char] = 1; //第一次出现 value是1\n    }\n}\n//统计最大值 max\nvar max = 0;\nfor(var key in obj){\n    if(max < obj[key]){\n        max = obj[key]\n    }\n}\n//拿最大值去对比\nfor(var key in obj){\n    if(obj[key] == max){\n        return key,max;\n    }\n}\n```\n\n15、new操作符具体做了什么？\n\n```\n1、创建了一空的对象\n2、将空对象的原型链 指向于构造函数的原型 new Foo().__proto__ = Foo().prototype\n3、改变了this的指向 将空对象作为构造函数的上下文\n4、对构造函数有返回值的处理判断\n\t如果返回的是一个基本类型 忽略\n\t如果是引用类型 则 new失效\n```\n\n16、闭包\n\n```js\n闭包是什么\n\t函数内部的嵌套函数在函数外部调用，可以访问函数的局部变量；\n闭包可以解决什么问题\nvar list = document.getElementsByTagName('li');\nfor(var i = 0;i < list.length;i++){//先执行同步 再执行异步点击事件\n    (function(i){\n        list[i].onclick =function(){\n            alert(i);\n        }\n        list[i] = null//清空闭包函数\n    })(i)\n}\n闭包的缺点：\n\t变量会驻留在内存中 造成内存泄漏\n    解决：把闭包的函数设置为null   list[i] = null\n```\n\n17、原型链\n\n```\n什么是原型：\n\t1、原型的好处：对象共享属性和方法\n\t2、谁拥有原型：函数拥有：prototype 对象拥有: __proto__\n\t3、对象查找属性和方法的顺序：对象本身，构造函数，对象的原型，构造函数的原型，构造函数的原型的原型\n什么是原型链：就是把原型串联起来 原型链的最顶端是null（绝大多数）\n原型可以解决什么问题：对象共享属性和方法\n```\n\n**18、JS继承有哪些方式？\n\n方式一：ES6的继承（extends） \n\n```js\nclass Parent{\n    constructor(){\n\t\tthis.age = 19;\n    }\n}\nclass Child extends Parent{\n    constructor(){\n        super();\n\t\tthis.name = 'zs';\n    }\n}\nvar person = new Child();\n```\n\n方式二:原型链继承\n\n```js\nfunction Parent(){\n\tthis.age = 20;\n}\nfunction Child(){\n\tthis.name =  'zs'\n}\nChild.prototype = new Parent();\nvar person = new Child();\nperson.age // 20\n```\n\n方式三：借用构造函数 call\n\n```js\nfunction Parent(){\n\tthis.age = 22;\n}\nfunction Child(){\n\tthis.name =  'zs'\n    Parent.call(this);\n}\n\nvar person = new Child();\nperson.age // 22\n```\n\n方法四：组合式继承：方法二+方法三；\n\n```js\nChild.prototype = new Parent();\nParent.call(this);\n```\n\n***方法五：圣杯模式：（路飞教育）\n\n```\n\n```\n\n19、说一下call apply bind的区别：（执行时间、传参）\n\n```js\n共同点:功能一致；都是改变this指向 \n不同点：1、call apply 可以立即执行。 bind不会立即执行，因为bind返回的是一个函数 需要加入（）才会执行。\n\t  2、参数不同：apply第二个参数是一个数组。 call和bind有多个参数要挨个写。\n应用场景：apply 立即执行，参数是一个数组；\n\t\tbind：执行异步函数 onclick = function(){ alert('ok')}\n\t\tcall:立即执行，参数是一个基本数据类型；\n```\n\n20、sort背后原理是什么？\n\n```js\n默认排序顺序时字符串的unicode码点\nv8引擎中使用了 排序算法 之前是插排和快排 现在是冒泡\nsort(function(a,b)=>{return a-b}) //升序排序\nsort(function(a,b)=>{return b-a}) //降序排序\nsort(function(a,b)=>{return a.age-b.age}) //对年龄进行升序排序\nsort(function(a,b)=>{return b.age-a.age}) //对年龄进行升序排序\n```\n\n22、深拷贝 浅拷贝\n\n```js\n什么是浅拷贝：对于引用数据，只复制了引用地址 没有复制真正的值，一个改变互相影响\nvar obj2 = Object.assign(obj1)\n什么是深拷贝：拷贝的真正的值 一个改变 互相不影响 \n```\n\n​\t*浅拷贝函数的封装：\n\n```js\nfunction clone(obj){\n\tvar newObj = {};\n    for(var prop in obj){\n        newObj[prop] = obj[prop];\n    }\n    return  newObj;\n}\n```\n\n​\t**深拷贝函数的封装：\n\n```js\nfunction deepclone(obj){\n    var newobj = Array.isArray(obj) ? {} : [];//判断obj是数组还是对象\n    for(var prop in obj){\n            if(typeOf(obj[prop]) == 'object'){//判断是引用类型\n               newObj[prop] = deepclone(obj[prop]);//递归实现引用类型属性的拷贝\n               }else{\n                   newObj[prop] = obj[prop]//基本数据类型直接拷贝\n               }\n        }\n    }\n    return newObj;\n}\n```\n\n23、localStorage sessionStorage  cookie的区别？\n\n```js\n共同点：在客户端存储数据\n不同点：\n\t\t1、存放有效期：\n\t\t\t\tlocalStorage   ：持久化存储，无法设置过期时间\n\t   \t\t\tsessionStorage：会话期存储 浏览器关闭 自动销毁，无法设置过期时间\n      \t\t\tcookies       :必须有一个线上环境 document.cookie ='name=789'可以设置过期时间\n       \t2、存储大小的限制：\n        \t\tcookies存储量不能超过4k local session 不能超过5M\n```\n\n**H5C3**\n\n1、什么是语义化标签：\n\n```html\nheader footer section artical\n优点：易读性和维护性好\n\t更加利于SEO搜索引擎优化\n\tIE8不兼容H5 解决：可以通过html5.shiv.js去处理\n```\n\n2、::before 和 :after 中双冒号和单冒号有什么区别：\n\n```js\n:伪类\n::为元素\n在布局上清楚浮动\n```\n\n3、promise有几种状态(async await 的区别 手写promise)\n\n```js\n进行中\n已成功\n已失败\n```\n\n4、数组迭代\n\n```\nforEach map find filter some every reduce indexOf lastIndexOf findIndex\n```\n\n**四：Vue面试题**\n\n1、vue2.x 生命周期有哪些\n\n```js\n系统自带的8个生命周期：\nbeforeCreate                               keep-alive  :activated\ncreated                                                :deactivated\nbeforeMount\nmounted\nbefore\nbeforeUpdate\nupdated\nbeforeDestroy\ndestroyed\n一旦进入组件或页面 会执行哪些生命周期？\n\tbeforeCreate created beforeMount mounted\n**在哪一个阶段有$el 哪一个阶段有$data\n\tcreated :最先有$data\n    mounted:最新有$el \n如果加入了keep-alive 第一次进入首页 会执行哪些生命周期 5个\n\tbeforeCreate created beforeMount mounted activated\n如果加入了keep-alive 第2次进入首页 会执行哪些生命周期？1个\n\tactivated\n```\n\n2、谈谈你对keep-alive的理解\n\n```JS\n1.是什么\n\tvue系统自带的一个组件，功能：是用来缓存组件的  ==》提升性能\n2.使用场景\n\t就是用来缓存组件，提升项目性能。 具体实现比如：首页进入到详情页，如果用户每次点击都是相同的，那么详情页就没必要请求N次了，直接缓存起来就可以了，当然如果点击的不是同一个，那么就得请求了。\n```\n\n3、v-if 和 v-show的区别\n\n```js\nv-if 把盒子删除掉再重新创建  使用场景：\nV-show 给元素添加display属性 值为none/block 会造成DOM的重绘和回流 \n\t 使用场景：初次加载 v-if 要比v-show好 页面不会加载盒子\n     \t\t频繁的切换 v-show 要比v-if好 创建和删除的开销太大了，显示和隐藏开销较小。\n```\n\n4、v-if 和v-for 的优先级\n\n```\nv-for的优先级要比v-if要高\n***在源码中体现的 11000左右\n```\n\n5、ref是什么\n\n```\n来获取DOM的 类似于getElementSById\n<div ref='divRef'></div>\nmounted(){\n\tthis.$refs.divRef\n}\n```\n\n6、nextTick是什么\n\n```\n获取更新后的DOM元素\n基本格式：this.$nextTick(回调函数)\nthis.$nextTick(()=>{\n\tthis.$refs.box.innerHTML = 'xxxxx'\n})\n场景：用到一些跟DOM相关的插件，比如bxxxx滑动的一些插件，我们的数据来自后台的接口，我们要把数据放到页面上，和插件有冲突，插件里面计算不到或者延迟记录数据内容，可能宽在记录上就有偏差，所以只能获取更新后的DOM，那么插件只能在 nextTick 中调用。\n```\n\n7、scoped原理\n\n```\n每一个组件的样式都是独立的，如果没有scoped 那么样式就会在所有的组件中都会生效。\n原理：给元素的节点新增自定义属性，data-v-xxx自定义属性 css根据属性选择器 添加样式。\n```\n\n8、Vue中如何样式穿透 \n\n```\n父元素 /deep/ 子元素 lang = scss\n父元素 >>> 子元素  lang= stylus\n```\n\n9、父传子\n\n```\n自定义属性\n父组件：<Header :msg=\"msg\"></Header>\nprops:[]\nprops:{\n\tmsg:数据类型\n}\n```\n\n10、子传父\n\n```\n自定义事件\n子组件：this.$emit('自定义事件'，传递的数据)\n父组件：<Header @自定义事件=\"父组件定义的方法\"></Header>\nexport default {\n\t\tdata(){\n\t\t\treturn{\n\t\t\t\tdata:{}\n\t\t\t}\n\t\t},\n\t\tmethods:{\n\t\t\t父组件的方法(msg){\n\t\t\t\tthis.data = msg\n\t\t\t}\n\t\t}\n}\n```\n\n11、兄弟组件之间的传值 \n\n```js\n中转站bus\nimport Vue from 'vue'\nexport default new Vue\nbus.$emit('自定义事件',传递的参数)\nbus.$on('自定义事件'，(传递的参数)=>{\n    this.data = 传递的参数\n})\n```\n\n12、computed 、methods、watch有什么区别？\n\n```\n1. computed  vs  methods\n相同点：都能返回数据\n不同点：computed有缓存 methhods 没有缓存\n2. computed vs watch\t\n\twatch；watch是侦听，数据或者路由发生改变才会响应；\n\tcomputed计算某一个属性的改变 如果每一个值改变了 计算属性会监听到进行返回\n\twatch是监听到数据改变了 才会执行内部代码\n\n```\n\n13、props和data优先级\n\n```\n源码 先判断props  再判断 methods  data  computed   watch \n```\n\n***13、vuex面试题\n\n```\nvuex 是状态管理模式  \nvuex有哪些属性\nstate  ==> data\ngetters ==> computed\nmutations ==> methods\nactions ==> 提交mutations\nmodules ==> 把以上属性再细分 让仓库更好管理\nexport default new Vuex.Store({\n\tmodules{\n\t\tcart,\n\t\tpath\n\t}\n})\n\tmapState({\n\t\tcartList:state=>state.cart.cartList,\n\t\tpathList:state=>state.path.pathList,\n\t})\n```\n\nmutations 和 actions 的区别 （同步 异步）\n\n```\nmutations:同步的任务  如果在mutations写异步任务 调试工具的数据层和视图层显示的数据 不同步\nactions: actions 提交的是mutations 而不是直接变更状态 actions可以包含任何异步操作   \n\t\t\tmutatons中调试工具的数据层和视图层显示的数据 不同步\n```\n\nvuex是单向数据流还是双向数据流\n\n```\n单向数据流 只读 无法更改 v-model绑定的mapState会报错 \n```\n\nvuex如何做持久化存储\n\n```\ncookie\nlocalStorage\n使用插件 vuex-p\n```\n\n14、Vue设置代理\n\n15、打包路径和路由模式\n\n16、代理和环境变量\n\n17、Vue路由面试题\n\n```\n\n```\n\n18、vue源码-模板解析\n\n19、vue源码-生命周期\n\n20、vue源码-添加事件\n\n21、vue源码-data劫持\n\n22、vue源码-更新视图\n\n23、v-model双向数据绑定\n\n24、diff算法开篇\n\n```\n功能：提升性能\ndom虚拟化： 核心：把dom结构数据化\n```\n\n25、snabbdom\n\n26、手写diff算法 -生成虚拟dom\n\n27、手写diff算法-patch不是同一个节点\n\n28、手写diff算法-相同节点有没有children\n\n29、diff算法核心 -理论部分\n\n30、手写diff算法-判断前四中情况\n\n31、手写diff算法-判断第5种情况\n\n32、手写diff算法 -创建和删除\n\n33、什么是MVVM？MVC MVP MVVM的理解？\n\n```\n\n```\n\n![web1.0时代](C:\\Users\\XINGJIANJIE\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220222234255569.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tweb1.0时代\n\n![image-20220222234454147](C:\\Users\\XINGJIANJIE\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220222234454147.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tweb2.0时代MVC分层架构 \n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tweb2.0时代 ajax出现之后 前后端分离 前端通过ajax与后端数据交互 服务端压力减少 用户\t\t\t\t\t\t\t\t\t\t\t体验提升 支持局部刷新 Jquery库的出现 操作DOM\n\n\n\n![image-20220222235006590](C:\\Users\\XINGJIANJIE\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220222235006590.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t前端MVC view  controlle r model\n\n![image-20220222235508533](C:\\Users\\XINGJIANJIE\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220222235508533.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t前端MVP model view presenter(中间人)\n\n![image-20220222235554968](C:\\Users\\XINGJIANJIE\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220222235554968.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tMVVM   model   view    viewModel(数据双向绑定)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tviewModel自动将数据变化转化为视图更新\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t数据驱动视图\n\n![image-20220222235932950](C:\\Users\\XINGJIANJIE\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220222235932950.png)\n\n这三个框架反应了web领域的发展进展，为了减少视图层和数据层的耦合问题\n\n节流阀和防抖\n\n节流：高频事件触发，n秒内只会执行一次，节流阀会稀释函数的执行频率\n\n防抖：触发高频事件后 n秒内只会执行一次 如果n秒内高频事件再次被触发则重新计算事件\n\n```\n节流阀 是一个开关 目的时为了避免频繁的向服务器请求数据 \n设计原理：\n每次请求数据之前打开节流阀 数据返回来之后再次关闭节流阀\n如果节流阀打开 则无法请求数据\n```\n\n```js\n防抖：触发高频事件后 n秒内只会执行一次 如果n秒内高频事件再次被触发则重新计算事件\nfunction debounce(fn){\n    let timeout = null;\n    return function(){\n        clearTimeout(timeout);\n        timeout = setTimeout(()=>{\n            fn.appay(this,arguments)\n        },500)\n    }\n}\n\nfunction sayHi(){console.log('防抖成功')}\nvar inp = document.getElementById('input')\ninp.addEventListener('input',debouce(fn))\n```\n\n**性能优化面试**\n\n1、vue性能优化\n\n2、加载优化\n\n3、图片优化\n\n4、渲染优化\n\n5、首屏加载慢的优化\n\n6、总结性能优化\n\n**页面样式兼容**\n\n**网络请求**\n\n1、跨域\n\n2、http和https的区别\n\n3、token\n\n4、seo\n\n","tags":["web前端"],"categories":["web前端"]},{"title":"继承与多态","url":"/2021/11/13/继承与多态/","content":"继承可以扩充已有类的功能 通过`extends`关键字实现\nthis() 调用本类构造   `super()`调用父类构造\n父类方法不希望被覆写，在方法之前加上`final`关键字\nfinal另一个功能是在数据成员变量之前加上`final`关键字，该变量就变成一个常量，便无法在程序代码之中对其进行修改`public static final`可以声明一个全局常量\n对象多态性主要分为 对象的自动向上转型和强制向下转型`学生是一个人，则学生类向人类转换是向上转换，人类向学生类转换是强制向下转换`\n `Person per= new Stuent stu；`   \n\n```js\nif(per instanceof Stuent){  //判断实例类型\n     Stuent newstu= （Stuent）per；//强制转换为子类实例，可以调用子类中的方法\n    \n}\n```\n\nObject类中的`toString`方法在子类中覆写\nObject类中的`equals`方法在子类中覆写\ninstanceof  判断是否是同一个对象 `per instanceof Person`判断对象per是否是Person类\n\n","tags":["继承"],"categories":["Java基础语法"]},{"title":"字符串基础语法","url":"/2021/11/10/字符串基础语法/","content":"### \"==\"与equals区别 ###\n\n```\n\npublic class Demo {\n\tpublic static void main(String[] args) {\n     String strA=\"helloworld\";\n     String strB= new String (\"helloworld\");\n     System.out.println(strA == strB);  // ==用于数字比较，如果用于对象比较上，是两个内存的地址的数值\n     System.out.println(strA.equals(strB));//equls类提供的一个比较方法，比较的是字符串内容的判断\n  }\n}\n\n```\n### 字符串对象（常量）池 ###\n- 静态常量池：指的程序在加载的时候自动将程序之中保存的字符串、常量等，全部进行分配\n- 运行时常量池：当一个程序加载之后，里面可能有一些变量\n\n```\npublic class Demo {\n\tpublic static void main(String[] args) {\n    String str = \"helloworld\";\n\tbyte s[] = str.getBytes();  //将字符串转化为字节数组\n\tfor (int i=0; i<s.length; i++)\n\t{   \n\t\ts[i]-=32;\t\t\n\t}\n\tSystem.out.println(new String(s));\n\tSystem.out.println(new String(s,0,5));\n  }\n}\n```\n### String类常用方法 ###\n```\npublic String​(char[] value)将传入的全部字符数组变为字符串\n---------------------------------------------------------------------------------------------------------\npublic String​(char[] value, int offset, int count)将部分字符数组变为字符串\n---------------------------------------------------------------------------------------------------------\npublic char charAt​(int index)获取指定索引位置的字符\n---------------------------------------------------------------------------------------------------------\npublic char[] toCharArray​()将字符串中的数据以字符数组的形式返回\n---------------------------------------------------------------------------------------------------------\npublic String​(byte[] bytes)将全部的字节数组变为字符串\n---------------------------------------------------------------------------------------------------------\npublic String​(byte[] bytes, int offset, int length)将部分字节数组变为字符串\n---------------------------------------------------------------------------------------------------------\npublic byte[] getBytes​() 将字符串转为字节数组\n---------------------------------------------------------------------------------------------------------\npublic boolean equals​(String anObject)区分大小写的相等判断\ntrue if the given object represents a String equivalent to this string, false otherwise\n---------------------------------------------------------------------------------------------------------\npublic boolean equalsIgnoreCase​(String anotherString)不区分大小写比较\n---------------------------------------------------------------------------------------------------------\npublic int compareTo​(String anotherString)进行字符串大小比较，该方法返回一个int数据，该数据有三种取值：大于（>0）、小于（<0）、等于（=0）。\n---------------------------------------------------------------------------------------------------------\npublic int compareToIgnoreCase​(String str)不区分大小写进行字符串大小比较\n---------------------------------------------------------------------------------------------------------\npublic public boolean contains​(String s)判断子字符串是否存在\n---------------------------------------------------------------------------------------------------------\npublic int indexOf​(String str)从头查找指定子字符串的位置，找不到返回-1\n---------------------------------------------------------------------------------------------------------\npublic int indexOf​(String str, int fromIndex)从指定位置查找指定字符串的位置\n---------------------------------------------------------------------------------------------------------\npublic int lastIndexOf​(String str)由后向前查找指定字符串的位置\n---------------------------------------------------------------------------------------------------------\npublic boolean startsWith​(String prefix)判断是否以指定的字符串开头\n---------------------------------------------------------------------------------------------------------\npublic boolean startsWith​(String prefix, int toffset)由指定位置判断是否以指定的字符串开头\n---------------------------------------------------------------------------------------------------------\npublic boolean endsWith​(String suffix)判断是否以指定的字符串结尾\n---------------------------------------------------------------------------------------------------------\npublic String replaceAll​(String regex, String replacement)全部替换\n---------------------------------------------------------------------------------------------------------\npublic String replaceFirst​(String regex, String replacement)替换首个\n---------------------------------------------------------------------------------------------------------\npublic String[] split​(String regex)按照指定的字符串全部拆分\n---------------------------------------------------------------------------------------------------------\npublic String[] split​(String regex, int limit)按照指定的字符串拆分为指定个数，后面不拆了\n---------------------------------------------------------------------------------------------------------\npublic String substring​(int beginIndex)从指定索引截取到结尾\n---------------------------------------------------------------------------------------------------------\npublic String substring​(int beginIndex, int endIndex)截取指定索引范围中的子字符串\n---------------------------------------------------------------------------------------------------------\npublic static String format​(String format, 各种类型 ... args)根据指定结构进行文本格式化显示\n---------------------------------------------------------------------------------------------------------\npublic String concat​(String str) //描述的就是字符串的连接,非静态的定义，没有入池\npublic class Test {\n    public static void main(String args[]) {\n        String s = \"菜鸟教程：\";\n        s = s.concat(\"www.runoob.com\");\n        System.out.println(s);\n    }\n}\n---------------------------------------------------------------------------------------------------------\npublic String intern​()字符串入池\n[https://blog.csdn.net/weichi7549/article/details/107731550](https://blog.csdn.net/weichi7549/article/details/107731550 \"Java之intern方法\")\n---------------------------------------------------------------------------------------------------------\npublic boolean isEmpty​()判断是否为空字符串（不是null）\n---------------------------------------------------------------------------------------------------------\npublic int length​()计算字符串的长度\n---------------------------------------------------------------------------------------------------------\npublic String trim​()去除左右的空格信息\nreturn: A string whose value is this string, with any leading and trailing white space removed, or this string if it has no leading or trailing white space.\n---------------------------------------------------------------------------------------------------------\npublic String toUpperCase​()字符串内容转大写\nReturns:\nthe String, converted to uppercase.\n---------------------------------------------------------------------------------------------------------\npublic String toLowerCase​()字符串内容转小写\nReturns:\nthe String, converted to lowercase.\n---------------------------------------------------------------------------------------------------------\n\n\n```\n\n\n\n","tags":["Sring"],"categories":["基础语法"]},{"title":"Django学习","url":"/2021/11/10/类关联结构/","content":"### -类关联结构 ###\n\n```\nclass Person {\n  private String name; //私有属性\n  private int age ;//私有属性\n  public Person (String name, int age){//构造方法\n\tthis.name = name; \n\tthis.age =age;\n  }\n  public String getInfo(){ //获取信息\n\treturn \"姓名：\"+ this.name +\"、年龄：\"+this.age;\n  }\n   private Car car;//一个人有一辆车，属性设置\n   public void setCar(Car car){\n\tthis.car =car;\n   }\n   public Car getCar(){\n\treturn this.car;\n   }\n}\nclass Car{\n\tprivate String brand;\n\tprivate double price;\n\tpublic Car(String brand, double price){\n\t\tthis.brand =brand;\n\t\tthis.price =price;\n\t}\n    public String getInfo(){\n\t\treturn \"品牌：\"+this.brand +\"、价格：\"+this.price;\n    }\n    private Person person;//\n\tpublic void setPerson(Person person){\n\t\tthis.person=person;\n\t}\n\tpublic Person getPerson(){\n\t\treturn this.person;\n\t}\n}\npublic class Demo {\n\tpublic static void main(String[] args) {\n\t\t//第一步：声明对象并设置彼此的关系\n\t  Person person =new Person(\"张伟\",29); //对象实例化\n\t  Car car =new Car(\"宝马\",580000.00);//对象实例化\n\t  person.setCar(car);  //一个人有一辆车,调用setcar方法\n\t  car.setPerson(person);//一辆车属于一辆车，调用setperson方法\n\t   //第二步：根据关系获取数据\n\t   System.out.println(person.getCar().getInfo());\n\t   System.out.println(car.getPerson().getInfo());\n\t      }\t\t\n       }\n\n```\n### 一对多关联 ###\n\n```\nclass Car {\t\t\t\t\t\t\t\t\t\t\t\t// 描述汽车\n\tprivate String name;\t\t\t\t\t\t\t\t// 汽车名称\n\tprivate double price;\t\t\t\t\t\t\t\t// 汽车价值\n\tprivate Person person; \t\t\t\t\t\t\t\t// 车应该属于一个人\n\tpublic Car(String name, double price) {\t\t\t\t// 构造传入汽车信息\n\t\tthis.name = name;\n\t\tthis.price = price;\n\t}\n \n\tpublic void setPerson(Person person) {\t\t\t\t// 配置汽车与人的关系\n\t\tthis.person = person;\n\t}\n \n\tpublic Person getPerson() {\t\t\t\t\t\t\t// 获取汽车拥有人信息\n\t\treturn this.person;\n\t}\n\tpublic String getInfo() {\t\t\t\t\t\t\t// 获取汽车信息\n\t\treturn \"汽车品牌型号：\" + this.name + \"、汽车价值：\" + this.price;\n\t}\n\t// setter、getter略\n}\nclass Person {\t\t\t\t\t\t\t\t\t\t// 描述人\n\tprivate String name;\t\t\t\t\t\t\t\t// 人的姓名\n\tprivate int age;\t\t\t\t\t\t\t\t\t// 人的年龄\n\tprivate Car car; \t\t\t\t\t\t\t\t\t// 一个人有一辆车，如果没有车则为null\n\tpublic Person(String name, int age) {\t\t\t\t// 构造传入人的信息\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t}\n\tpublic void setCar(Car car) {\t\t\t\t\t\t// 设置人与汽车的关系\n\t\tthis.car = car;\n\t}\n\tpublic Car getCar() {\t\t\t\t\t\t\t\t// 获取人对应的汽车信息\n\t\treturn this.car;\n\t}\n\tpublic String getInfo() {\t\t\t\t\t\t\t// 获取人员信息\n\t\treturn \"姓名：\" + this.name + \"、年龄：\" + this.age;\n\t}\n\t// setter、getter略\n}\npublic class JavaDemo {\n\tpublic static void main(String args[]) {\n\t\t// 第一步：声明对象并且设置彼此的关系\n\t\tPerson person = new Person(\"林希勒\", 29);\t\t// 实例化Person类对象\n\t\tCar car = new Car(\"奔驰G50\", 1588800.00);\t\t// 实例化Car类对象\n\t\tperson.setCar(car); \t\t\t\t\t\t\t// 一个人有一辆车\n\t\tcar.setPerson(person); \t\t\t\t\t\t// 一辆车属于一个人\n\t\t// 第二步：根据关系获取数据\n\t\tSystem.out.println(person.getCar().getInfo()); // 通过人获取汽车的信息\n\t\tSystem.out.println(car.getPerson().getInfo());\t// 通过汽车获取拥有人的信息\n\t}\n}\nclass Car {\t\t\t\t\t\t\t\t\t\t\t\t// 描述汽车\n\tprivate String name;\t\t\t\t\t\t\t\t// 汽车名称\n\tprivate double price;\t\t\t\t\t\t\t\t// 汽车价值\n\tprivate Person person; \t\t\t\t\t\t\t\t// 车应该属于一个人\n\tpublic Car(String name, double price) {\t\t\t\t// 构造传入汽车信息\n\t\tthis.name = name;\n\t\tthis.price = price;\n\t}\n \n\tpublic void setPerson(Person person) {\t\t\t\t// 配置汽车与人的关系\n\t\tthis.person = person;\n\t}\n \n\tpublic Person getPerson() {\t\t\t\t\t\t\t// 获取汽车拥有人信息\n\t\treturn this.person;\n\t}\n\tpublic String getInfo() {\t\t\t\t\t\t\t// 获取汽车信息\n\t\treturn \"汽车品牌型号：\" + this.name + \"、汽车价值：\" + this.price;\n\t}\n\t// setter、getter略\n}\nclass Person {\t\t\t\t\t\t\t\t\t\t// 描述人\n\tprivate String name;\t\t\t\t\t\t\t\t// 人的姓名\n\tprivate int age;\t\t\t\t\t\t\t\t\t// 人的年龄\n\tprivate Car car; \t\t\t\t\t\t\t\t\t// 一个人有一辆车，如果没有车则为null\n\tpublic Person(String name, int age) {\t\t\t\t// 构造传入人的信息\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t}\n\tpublic void setCar(Car car) {\t\t\t\t\t\t// 设置人与汽车的关系\n\t\tthis.car = car;\n\t}\n\tpublic Car getCar() {\t\t\t\t\t\t\t\t// 获取人对应的汽车信息\n\t\treturn this.car;\n\t}\n\tpublic String getInfo() {\t\t\t\t\t\t\t// 获取人员信息\n\t\treturn \"姓名：\" + this.name + \"、年龄：\" + this.age;\n\t}\n\t// setter、getter略\n}\npublic class JavaDemo {\n\tpublic static void main(String args[]) {\n\t\t// 第一步：声明对象并且设置彼此的关系\n\t\tPerson person = new Person(\"林希勒\", 29);\t\t// 实例化Person类对象\n\t\tCar car = new Car(\"奔驰G50\", 1588800.00);\t\t// 实例化Car类对象\n\t\tperson.setCar(car); \t\t\t\t\t\t\t// 一个人有一辆车\n\t\tcar.setPerson(person); \t\t\t\t\t\t// 一辆车属于一个人\n\t\t// 第二步：根据关系获取数据\n\t\tSystem.out.println(person.getCar().getInfo()); // 通过人获取汽车的信息\n\t\tSystem.out.println(car.getPerson().getInfo());\t// 通过汽车获取拥有人的信息\n\t}\n}\n\n```\n### 数据表与简单java类映射转换 ###\n```\nclass Dept {\n   private long deptno;\n   private String dname;\n   private String loc;\n   private Emp emps[];  //保存多个雇员信息\n   public Dept(long deptno,String dname, String loc){\n\tthis.dname=dname;\n\tthis.deptno=deptno;\n\tthis.loc =loc;\n   }\n  public void setEmps(Emp[] emps){  //设置部门与雇员的关联\n\tthis.emps=emps;\n  }\n  public Emp[] getEmps(){\n\treturn this.emps;\n  }\n  public String getInfo(){\n\treturn \"【部门信息】部门编号 =\"+this.deptno+\"部门名称 =\"\n\t\t+this.dname+\"部门位置 =\"+this.loc;\n  }\n}\nclass Emp{\n\t  private long empno;\n\t  private String ename;\n\t  private String job;\n\t  private double sal;\n\t  private double common;\n\t  private Dept dept;\n\t  private Emp mgr;\n\t  public Emp(long empno,String ename,String job,double sal,double common){\n\t\tthis.empno =empno;\n\t\tthis.ename=ename;\n\t\tthis.job=job;\n\t\tthis.sal=sal;\n\t\tthis.common=common; \n\t  }\n\t  public String getInfo(){\n\t\treturn \"【雇员信息】编号=\"+this.empno+\"姓名=\"+this.ename+\"职位=\"+this.job+\"工资=\"+\n\t\t\tthis.sal+\"津贴\"+this.common;\n\t  }\n\t  public void setDept(Dept dept){ \n\t\tthis.dept=dept;\n\t  }\n\t  public void setMgr(Emp mgr){\n\t\tthis.mgr =mgr;\n\t  }\n\t  public Dept getDept(){\n\t\treturn this.dept;\n\t  }\n\t  public Emp getMgr(){\n\t\treturn this.mgr;\n\t  }\n}\npublic class Demo {\n\tpublic static void main(String[] args) {\n\t\t\tDept dept=new Dept(10,\"技术部\",\"南京\");\n\t\t\tEmp empA = new Emp(5925L,\"luck\",\"P1\",4000.00,0.00); //雇员信息\n\t\t\tEmp empB = new Emp(7585L,\"hope\",\"P2\",6000.00,400.00);//雇员信息\n\t\t\tEmp empC = new Emp(7725L,\"raw\",\"P3\",8000.00,800.00);//\n\t\t\tempA.setDept(dept);//设置雇员与部门的关联\n\t\t\tempB.setDept(dept);//设置雇员与部门的关联\n\t\t\tempC.setDept(dept);//设置雇员与部门的关联\n\t\t\tempA.setMgr(empB); //设置雇员与领导的关联\n\t\t\tempB.setMgr(empC);//设置雇员与领导的关联\n\t\t\tdept.setEmps(new Emp[] {empA,empB,empC});// 部门与雇员\n\t\t\tSystem.out.println(dept.getInfo());  // 部门信息\n\t\t\tfor (int x =0;x<dept.getEmps().length ;x++ )\n\t\t\t{  System.out.println(dept.getEmps()[x].getInfo());\n\t\t         if (dept.getEmps()[x].getMgr() !=null){// 该雇员存在有领导\n\t\t\t       System.out.println(dept.getEmps()[x].getMgr().getInfo());\n\t\t   }\t\n       }\n\t   System.out.println(\"---------------------------------------------------\");\n       System.out.println(empB.getDept().getInfo());// 根据雇员获取部门信息\n       System.out.println(empB.getMgr().getInfo());// 根据雇员获取领导信息\n\n  \n  }\n}   \n\t\t代码结果：\n\t\t\t    【部门信息】部门编号 =10部门名称 =技术部部门位置 =南京\n\t\t\t\t【雇员信息】编号=5925姓名=luck职位=P1工资=4000.0津贴0.0\n\t\t\t\t【雇员信息】编号=7585姓名=hope职位=P2工资=6000.0津贴400.0\n\t\t\t\t【雇员信息】编号=7585姓名=hope职位=P2工资=6000.0津贴400.0\n\t\t\t\t【雇员信息】编号=7725姓名=raw职位=P3工资=8000.0津贴800.0\n\t\t\t\t【雇员信息】编号=7725姓名=raw职位=P3工资=8000.0津贴800.0\n---------------------------------------------------\n【部门信息】部门编号 =10部门名称 =技术部部门位置 =南京\n【雇员信息】编号=7725姓名=raw职位=P3工资=8000.0津贴800.0\n\n```\n### 多对多 ###\n\n```\n class Member {\n\tprivate String mid ;\n\tprivate String name ;\n\tprivate Product products [] ;\n\tpublic Member(String mid,String name) {\n\t\tthis.mid = mid ;\n\t\tthis.name = name ;\n\t}\n\tpublic void setProducts(Product products []) {\n\t\tthis.products = products ;\n\t}\n\tpublic Product [] getProducts() {\n\t\treturn this.products ;\n\t}\n\tpublic String getInfo() {\n\t\treturn \"【用户信息】mid = \" + this.mid + \"、name = \" + this.name ;\n\t}\n}\nclass Product {\n\tprivate long pid ;\n\tprivate String title ;\n\tprivate double price ;\n\tprivate Member members [] ;\n\tpublic Product(long pid,String title,double price) {\n\t\tthis.pid = pid ;\n\t\tthis.title = title ;\n\t\tthis.price = price ;\n\t}\n\tpublic void setMembers(Member members[]) {\n\t\tthis.members = members ;\n\t}\n\tpublic Member [] getMembers() {\n\t\treturn this.members ;\n\t}\n\tpublic String getInfo() {\n\t\treturn \"【商品信息】pid = \" + this.pid + \"、title = \" + this.title + \"、price = \" + this.price ;\n\t}\n}\npublic class JavaDemo {\n\tpublic static void main(String args[]) {\n\t\t// 第一步：根据结构设置对象数据\n\t\tMember memA = new Member(\"mldn\",\"张三\") ;\n\t\tMember memB = new Member(\"mldnjava\",\"李四\") ;\n\t\tProduct proA = new Product(1L,\"Java开发图书\",79.8) ;\n\t\tProduct proB = new Product(2L,\"非常大的B的耳机\",2309.8) ;\n\t\tProduct proC = new Product(3L,\"小米手机\",3000.8) ;\n\t\tmemA.setProducts(new Product[] {proA,proB,proC} ) ;\n\t\tmemB.setProducts(new Product[] {proA} ) ;\n\t\tproA.setMembers(new Member[] {memA,memB}) ;\n\t\tproB.setMembers(new Member[] {memA}) ;\n\t\tproC.setMembers(new Member[] {memA}) ;\n\t\t// 第二步：根据要求获取数据\n\t\tSystem.out.println(\"--------------- 根据用户查看浏览商品信息 -----------------\") ;\n\t\tSystem.out.println(memA.getInfo()) ;\n\t\tfor (int x = 0 ; x < memA.getProducts().length ; x ++) {\n\t\t\tSystem.out.println(\"\\t|- \" + memA.getProducts()[x].getInfo()) ;\n\t\t}\n\t\tSystem.out.println(\"--------------- 根据商品找到被浏览的记录 -----------------\") ;\n\t\tSystem.out.println(proA.getInfo()) ;\n\t\tfor (int x = 0 ; x < proA.getMembers().length ; x ++) {\n\t\t\tSystem.out.println(\"\\t|- \" + proA.getMembers()[x].getInfo()) ;\n\t\t}\n\t}\n}\n \n ```\n\n\n\n### 一对多、多对多综合 ###\n\n```\nclass Member {\n\tprivate String mid ;\n\tprivate String name ;\n\tprivate Role roles [] ; \n\tpublic Member(String mid,String name) {\n\t\tthis.mid = mid ;\n\t\tthis.name = name ;\n\t}\n\tpublic void setRoles(Role roles[]) {\n\t\tthis.roles = roles ;\n\t}\n\tpublic Role [] getRoles() {\n\t\treturn this.roles ;\n\t}\n\tpublic String getInfo() {\n\t\treturn \"【用户信息】mid = \" + this.mid + \"、name = \" + this.name ;\n\t}\n}\nclass Role {\n\tprivate long rid ;\n\tprivate String title ;\n\tprivate Member members [] ;\n\tprivate Privilege privileges [] ;\n\tpublic Role(long rid,String title) {\n\t\tthis.rid = rid ;\n\t\tthis.title = title ;\n\t}\n\tpublic void setMembers(Member members []) {\n\t\tthis.members = members ;\n\t}\n\tpublic Member [] getMembers() {\n\t\treturn this.members ;\n\t}\n\tpublic void setPrivileges(Privilege privileges []) {\n\t\tthis.privileges = privileges ;\n\t}\n\tpublic Privilege [] getPrivileges() {\n\t\treturn this.privileges ;\n\t}\n\tpublic String getInfo() {\n\t\treturn \"【角色信息】rid = \" + this.rid + \"、title = \" + this.title ;\n\t}\n}\nclass Privilege {\n\tprivate long pid ;\n\tprivate String title ;\n\tprivate Role role ;\n\tpublic Privilege(long pid,String title) {\n\t\tthis.pid = pid ;\n\t\tthis.title = title ;\n\t}\n\tpublic void setRole(Role role) {\n\t\tthis.role = role ;\n\t}\n\tpublic Role getRole() {\n\t\treturn this.role ;\n\t}\n\tpublic String getInfo() {\n\t\treturn \"【权限信息】pid = \" + this.pid + \"、title = \" + this.title ;\n\t}\n}\npublic class JavaDemo {\n\tpublic static void main(String args[]) {\n\t\t// 第一步：根据结构设置对象数据\n\t\tMember memA = new Member(\"mldn-a\",\"张三\") ;\n\t\tMember memB = new Member(\"mldn-b\",\"李四\") ;\n\t\tRole roleA = new Role(1L,\"系统配置\") ;\n\t\tRole roleB = new Role(2L,\"备份管理\") ;\n\t\tRole roleC = new Role(3L,\"人事管理\") ;\n\t\tPrivilege priA = new Privilege(1000L,\"系统初始化\") ;\n\t\tPrivilege priB = new Privilege(1001L,\"系统系统还原\") ;\n\t\tPrivilege priC = new Privilege(1002L,\"系统环境修改\") ;\n\t\tPrivilege priD = new Privilege(2000L,\"备份员工数据\") ;\n\t\tPrivilege priE = new Privilege(2001L,\"备份部门数据\") ;\n\t\tPrivilege priF = new Privilege(2002L,\"备份公文数据\") ;\n\t\tPrivilege priG = new Privilege(3000L,\"增加员工\") ;\n\t\tPrivilege priH = new Privilege(3001L,\"编辑员工\") ;\n\t\tPrivilege priI = new Privilege(3002L,\"浏览员工\") ;\n\t\tPrivilege priJ = new Privilege(3003L,\"员工离职\") ;\n\t\t// 增加角色与权限的对应关系\n\t\troleA.setPrivileges(new Privilege[] {priA,priB,priC}) ;\n\t\troleB.setPrivileges(new Privilege[] {priD,priE,priF}) ;\n\t\troleC.setPrivileges(new Privilege[] {priG,priH,priI,priJ}) ;\n\t\t// 增加权限与角色对应\n\t\tpriA.setRole(roleA) ;\n\t\tpriB.setRole(roleA) ;\n\t\tpriC.setRole(roleA) ;\n\t\tpriD.setRole(roleB) ;\n\t\tpriE.setRole(roleB) ;\n\t\tpriF.setRole(roleB) ;\n\t\tpriG.setRole(roleC) ;\n\t\tpriH.setRole(roleC) ;\n\t\tpriI.setRole(roleC) ;\n\t\tpriJ.setRole(roleC) ;\n\t\t// 增加用户与角色的对应关系\n\t\tmemA.setRoles(new Role[] {roleA,roleB}) ;\n\t\tmemB.setRoles(new Role[] {roleA,roleB,roleC}) ;\n\t\troleA.setMembers(new Member[] {memA,memB}) ;\n\t\troleB.setMembers(new Member[] {memA,memB}) ;\n\t\troleC.setMembers(new Member[] {memB}) ;\n\t\t// 第二步：根据要求获取数据\n\t\tSystem.out.println(\"------ 通过用户查找信息 ------\") ;\n\t\tSystem.out.println(memB.getInfo()) ;\n\t\tfor (int x = 0 ; x < memB.getRoles().length ; x ++) {\n\t\t\tSystem.out.println(\"\\t|- \" + memB.getRoles()[x].getInfo()) ;\n\t\t\tfor (int y = 0 ; y < memB.getRoles()[x].getPrivileges().length ; y ++) {\n\t\t\t\tSystem.out.println(\"\\t\\t|- \" + memB.getRoles()[x].getPrivileges()[y].getInfo()) ;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"------ 通过角色查找信息 ------\") ;\n\t\tSystem.out.println(roleB.getInfo()) ;\n\t\tSystem.out.println(\"\\t|- 浏览此角色下的所有权限信息：\") ;\n\t\tfor (int x = 0 ; x < roleB.getPrivileges().length ; x ++) {\n\t\t\tSystem.out.println(\"\\t\\t|- \" + roleB.getPrivileges()[x].getInfo()) ;\n\t\t}\n\t\tSystem.out.println(\"\\t|- 浏览此角色下的所有用户信息：\") ;\n\t\tfor (int x = 0 ; x < roleB.getMembers().length ; x ++) {\n\t\t\tSystem.out.println(\"\\t\\t|- \" + roleB.getMembers()[x].getInfo()) ;\n\t\t}\n\t\tSystem.out.println(\"------ 通过权限查找信息 ------\") ;\n\t\tSystem.out.println(priA.getInfo()) ;\n\t\tfor (int x = 0 ; x < priA.getRole().getMembers().length ; x++) {\n\t\t\tSystem.out.println(\"\\t|- \" + priA.getRole().getMembers()[x].getInfo()) ;\n\t\t}\n\t}\n}\n\n  ```\n","tags":["python"],"categories":["类关联结构"]},{"title":"对象数组","url":"/2021/11/10/对象数组/","content":"动态初始化\n\n```\nclass Person {\t// 引用类型\n\tprivate String name ;// 成员属性\n\tprivate int age ;\t// 成员属性\n\tpublic Person(String name,int age) {\t// 属性初始化\n\t\tthis.name = name ;\t// 为name属性赋值\n\t\tthis.age = age ;\t// 为age属性赋值\n\t}\n\tpublic String getInfo() {// 获取对象信息\n\t\treturn \"姓名：\" + this.name \n\t\t\t+ \"、年龄：\" + this.age ;\n\t}\n\t// setter、getter略\n}\npublic class ArrayDemo {\n\tpublic static void main(String args[]) {\n\t\tPerson per [] = new Person[3] ; \t// 对象数组动态初始化\n\t\tper[0] = new Person(\"张三\", 20);\t// 为数组赋值\n\t\tper[1] = new Person(\"李四\", 18);\t// 为数组赋值\n\t\tper[2] = new Person(\"王五\", 19);\t// 为数组赋值\n\t\tfor (int x = 0; x < per.length; x++) {// 循环输出\n\t\t\tSystem.out.println(per[x].getInfo());\n\t\t}\n\t}\n}\n\n```\n\n```\nclass Person {\n  private String name; //私有属性\n  private int age ;//私有属性\n  public Person (String name, int age){//构造方法\n\tthis.name = name; \n\tthis.age =age;\n  }\n  public String getInfo(){ //获取信息\n\treturn \"姓名：\"+ this.name +\"年龄：\"+this.age;\n  }\n}\npublic class Demo {\n\tpublic static void main(String[] args) {\n\t   Person per []=new Person[3];  //数组对象\n\t   per[0] =new Person(\"张三\",25);\n\t   per[1] =new Person(\"李素\",25);\n\t   per[2] =new Person(\"王五\",25);\n\t   for (int x =0;x<per.length ;x++ ){\n\t\t   System.out.println(per[x].getInfo());\n\t        }\n\t      }\t\t\n       }\n代码运行结果：\n姓名：张三年龄：25\n姓名：李素年龄：25\n姓名：王五年龄：25\n\n```\n\n静态初始化\n\n```\npublic class ArrayDemo {\n\tpublic static void main(String args[]) {\n\t\tPerson per[] = new Person[] { \n\t\t\t\tnew Person(\"张三\", 20), new Person(\"李四\", 18), \n\t\t\t\tnew Person(\"王五\", 19) }; \t// 对象数组静态初始化\n\t\tfor (int x = 0; x < per.length; x++) {\t// 循环输出\n\t\t\tSystem.out.println(per[x].getInfo());\n\t\t}\n\t}\n}\n\n```\n","tags":["Java基本语法"],"categories":["对象数组"]},{"title":"数组的基本操作","url":"/2021/11/09/数组的基本操作/","content":"### 数组冒泡排序法 ###\n\n```\n\npublic class Demo {\n\tpublic static void main(String[] args) {\n\t int data [] = new int [] {8,9,1,7,6,4,0,2,3,5,10};\n\t for ( int i = 1;i<data.length ;i++ )\n\t   {      for ( int j=0;j<data.length-i; j++)\n\t      {     if (data[j] >data[j+1])\n\t            {    \n\t              int temp =data[j];\n\t\t\t\t  data[j]=data[j+1];\n\t\t\t\t  data[j+1]=temp;\n\t            }\t\t\n\t      }\n\t }\n\t printArray(data);\n\t}\n\tpublic static void printArray(int temp[]){\n\t\tfor (int x=0;x<temp.length ;x++ ){\n\t\t     System.out.println(temp[x]+\"、\");\n\t\t}\n\t\tSystem.out.println();\n\t}\t\t\n}\n\n```\n\n- 利用类中函数实现排序，简化主类中代码结构\n\n```\nclass ArrayUtil{\npublic static void sort(int data[]){\n\t\tfor ( int i = 1;i<data.length ;i++ )\n\t   {      for ( int j=0;j<data.length-i; j++)\n\t      {     if (data[j] >data[j+1])\n\t            {    \n\t              int temp =data[j];\n\t\t\t\t  data[j]=data[j+1];\n\t\t\t\t  data[j+1]=temp;\n\t            }\t\t\n\t      }\n\t }\n\t}\npublic static void printArray(int temp[]){\n\t\tfor (int x=0;x<temp.length ;x++ ){\n\t\t     System.out.print(temp[x]+\"、\");\n\t\t}\n\t\tSystem.out.println();\n\t}\t\n}\n\npublic class Demo {//主类\n\tpublic static void main(String[] args) {//主方法\n\t int data [] = new int [] {8,9,1,7,6,4,0,2,3,5,10};\n\t ArrayUtil.sort(data); //调用类方法\n\t ArrayUtil.printArray(data);//调用类方法\n\t}\n\t\t\n}\n\n```\n### 数组反转排序 ###\n- \ndata=temp   产生垃圾\n\n```\nint data [] = new int [] {8,9,1,7,6,4,0,2,3,5,10};\n\t int temp [] =new int [data.length]; //第二个数组\n\t int foot =temp.length -1;//第二个数组的角标\n\t for (int x=0;x <data.length ;x++ )\n\t {  temp[foot--]=data[x];\n\t }\n```\n\n为了不产生垃圾，在一个数组里进行\n\n```\nclass ArrayUtil{\n\tpublic static void sort(int data[]){\n\t\tfor ( int i = 1;i<data.length ;i++ )\n\t   {      for ( int j=0;j<data.length-i; j++)\n\t      {     if (data[j] >data[j+1])\n\t            {    \n\t              int temp =data[j];\n\t\t\t\t  data[j]=data[j+1];\n\t\t\t\t  data[j+1]=temp;\n\t            }\t\t\n\t      }\n\t }\n\t}\n public static void printArray(int temp[]){\n\t\tfor (int x=0;x<temp.length ;x++ ){\n\t\t     System.out.print(temp[x]+\"、\");\n\t\t}\n\t\tSystem.out.println();\n\t}\t\n}\n\npublic class Demo {\n\tpublic static void main(String[] args) {\n\t int data [] = new int [] {1,2,3,4,5,6,7,8,9,10};\n\t System.out.print(\"转置前数组:\");\n\t ArrayUtil.printArray(data);\n\t for (int x=0;x <data.length/2 ;x++ )\n\t {   int temp = data[x];\n\t     data[x]= data[data.length-1-x];\n          data[data.length-1-x]=temp;\n\t }\n    System.out.print(\"转置后数组:\");\n\t ArrayUtil.printArray(data);\n\t}\n\t\t\n}\n\n```\n\n###  直接选择排序 ###\n\n```\nclass ArrayUtil{\n\n\tpublic static void printArray(int temp[]){\n\t\tfor (int x=0;x<temp.length ;x++ ){\n\t\t     System.out.print(temp[x]+\"、\");\n\t\t}\n\t\tSystem.out.println();\n\t}\t\n}\n\npublic class Demo {\n\tpublic static void main(String[] args) {\n\t int data [] = new int [] {8,9,1,7,6,4,0,2,3,5,10};\n\t System.out.print(\"排序前数组:\");\n\t ArrayUtil.printArray(data);\n\t for (int i=1; i<data.length; i++){\n\t\n\t\n\t for (int x=1; x <data.length-i ;x++ )\n\t {   \n\t\t int index =0; //第一个数最大\n\t\t if (data[x] >data[index]) // 比较最大的值给index\n\t\t {   index =x;\n\t\t }\n\t } \n\t //index的值给最后一位\n\t  int tem=data[index]; \n\t  data[index]=data[data.length-i-1];\n\t   data[data.length-i-1]=tem;\n\t }\n    System.out.print(\"排序后数组:\");\n\t ArrayUtil.printArray(data);\n\t}\n\t\t\n}\n\n```\n\n\n","tags":["Java数组"],"categories":["Java基本语法"]},{"title":"this关键字的使用","url":"/2021/11/08/this关键字的使用/","content":"### this调用基本方法 ###\n\n\n\n1. 当前类中的属性：this.属性；\n2. 当前类中的方法（普通方法、构造方法）：this()、this.方法名称()；\n3. 描述当前对象；\n\nthis.属性名称访问本类中的属性\n\n```\nclass Person{//一个类\n\tprivate String name; //类的属性\n\tprivate int age; //类的属性\n\tpublic Person(String name,int age){ //构造方法，参数名称不哈为\n\t\tthis.name=name;    //this.属性名称访问类中属性\n\t\tthis.age=age;     //this.属性名称访问类中属性\n\t}\n\tpublic void tell(){\n\t\tSystem.out.println(\"姓名：\"+name+\"、年龄：\"+age);\n\t}\n\t//setter、getter略\n}\npublic class Dir{   //主类\npublic static void main(String[] args) \n\t{\n\t\tPerson per =new Person(\"王五\",38);\n\t\tper.tell();\n\t}\n}\n\n ```\n构造方法调用this()\n普通方法调用this.方法名称()\n\n```\nclass Person{//一个类\n\tprivate String name; //类的属性\n\tprivate int age; //类的属性\n\tpublic Person(String name,int age){ //构造方法\n\t\tthis.setName(name);    //this.方法名称调用类中普通方法\n\t\tthis.setAge(age);     //this.方法名称调用类中普通方法\n\t}\n\tpublic void tell(){\n\t\tSystem.out.println(\"姓名：\"+name+\"、年龄：\"+age);\n\t}\n\tpublic void setName(String name){\n\t\tthis.name=name;\n\t}\n\tpublic void setAge(int age){\n\t\tthis.age=age;\n\t}\n\tpublic String getName(){\n\t\treturn this.name;\n\t}\n\tpublic int getAge(){\n\t\treturn this.age;\n\t}\n}\npublic class Dir{   //主类\npublic static void main(String[] args) \n\t{\n\t\tPerson per =new Person(\"王五\",38);\n\t\tper.tell();\n\t}\n}\n\n ```\n\n三参构造，代码有大量重复，可以利用this()优化代码\n\n优化前：\n\n```\nclass Emp{//一个类\n\tprivate long empno;   //员工编号\n\tprivate String ename;  //员工姓名\n\tprivate String dept;  //员工部门\n\tprivate double salary;  //基本工资\n\t//定个4个构造\n\tpublic Emp(){ //无参构造\n\t\tthis.empno=10000;\n\t\tthis.ename=\"无名氏\";\n\t}\n\tpublic Emp(long empno){//单参构造\n\t\tthis.empno=empno;\n\t    this.ename=\"新员工\";\n\t\tthis.dept=\"未定\";\n\t}\n\tpublic Emp(long empno,String ename,String dept){//三参构造\n\t\tthis.empno=empno;\n\t\tthis.ename=ename;\n\t\tthis.dept=dept;\n\t\tthis.salary=5600;\n\n\t}\n\tpublic String getInfo(){\n\t\treturn \"员工编号：\"+this.empno +\n\t\t\t\"、员工姓名：\"+this.ename+\n\t\t\t\"、员工部门：\"+this.dept+\n\t\t\t\"、基本工资：\"+this.salary;\n\t}\n\t\n}\npublic class Dir{   //主类\npublic static void main(String[] args) \n\t{\n\t\tEmp emp =new Emp(5655L,\"王五\",\"市场部\");\n\t\tSystem.out.println(emp.getInfo());\n\t}\n}\n\n```\nthis()优化后：\n\n```\nclass Emp{//一个类\n\tprivate long empno;   //员工编号\n\tprivate String ename;  //员工姓名\n\tprivate String dept;  //员工部门\n\tprivate double salary;  //基本工资\n\t//定个4个构造\n\tpublic Emp(){ //无参构造\n\t\tthis(1000,\"无名氏\",null,0.0);//等价于以下两行代码\n\t\t//this.empno=10000;ja\n\t\t//this.ename=\"无名氏\";\n\t}\n\tpublic Emp(long empno){//单参构造\n\t\tthis(empno,\"新员工\",\"未定\",0.0);//等价于以下三行代码\n\t\t//this.empno=empno;\n\t    //this.ename=\"新员工\";\n\t\t//this.dept=\"未定\";\n\t}\n\tpublic Emp(long empno,String ename,String dept){//三参构造\n\t\tthis(empno,ename,dept,5688.00);//等价于以下三行代码\n\t\t//this.empno=empno;\n\t\t//this.ename=ename;\n\t\t//this.dept=dept;\n\t\t//this.salary=5600;\n\t}\n\tpublic Emp(long empno,String ename,String dept,double salary){//四参构造\n\t\tthis.empno=empno;\n\t\tthis.ename=ename;\n\t\tthis.dept=dept;\n\t\tthis.salary=salary;\n\n\t}\n\tpublic String getInfo(){\n\t\treturn \"员工编号：\"+this.empno +\n\t\t\t\"、员工姓名：\"+this.ename+\n\t\t\t\"、员工部门：\"+this.dept+\n\t\t\t\"、基本工资：\"+this.salary;\n\t}\n\t\n}\npublic class Dir{   //主类\npublic static void main(String[] args) \n\t{\n\t\tEmp emp =new Emp(5655L,\"王五\",\"市场部\");\n\t\tSystem.out.println(emp.getInfo());\n\t}\n}\n\n```\n### this表示当前对象 ###\n一个类可以实例化出若干个对象，这些对象都可以调用类中的方法\n\n### 简单java类代码 ###\n\n```\nclass Dept{\n\tprivate long deptno;\n\tprivate String dname;\n\tprivate String loc;\n\tprivate Dept(){\n\t\t\n\t}\n\tpublic Dept(long deptno,String dname,String loc){\n\t\tthis.deptno=deptno;\n\t\tthis.dname=dname;\n\t\tthis.loc=loc;\n\t}\n\tpublic String getInfo(){\n\t\treturn \"部门编号\"+this.deptno+\"部门名称\"+this.dname+\"部门位置\"+this.loc;\n\t}\n   public void setDeptno(long deptno){\n\tthis.deptno=deptno;\n   }\n   public void setDname(String dname){\n\tthis.dname=dname;\n   }\n   public void setLoc(String loc){\n\tthis.loc=loc;\n   }\n   public String getDname(){\n\t     return this.dname;\n   }\n  public long getDeptno(){\n\treturn this.deptno;\n  }\n  public String getLoc(){\n\treturn this.loc;\n  }\n\n}\n\npublic class Demo \n{\n\tpublic static void main(String[] args) \n\t{\n\t\tDept dept = new Dept(1000,\"技术部\",\"南京市\");\n      System.out.println(dept.getInfo());\n\t}\n}\n\n   ```\n### 单独创建一个static ###\n\n```\nclass Book {\n\tprivate String title;\n\tprivate static int count =0;\n\tpublic Book(String title){\n\t\tthis.title = title;\n\t\tcount ++;\n\t\tSystem.out.println(\"第\"+ count +\"本图书创建出来；\");\n\t}\t\n\t}\n\t\npublic class Demo \n{\n\tpublic static void main(String[] args) \n\t{\n\t\tnew Book(\"Java\"); new Book (\"JSP\");\n\t}\n}\n结果：\n第1本图书创建出来；\n第2本图书创建出来；\n   ```\n\n\n```\nclass Book {\n\tprivate String title;\n\tprivate static int count =0;\n\tpublic Book(){  //无参构造\n\t\tthis(\"NUTITLE--\" +count++);\n\t}\n\tpublic Book(String title){\n\t\tthis.title = title;\n\t\t//System.out.println(\"第\"+ count +\"本图书创建出来；\");\n\t}\t\n\tpublic String getTitle(){\n\t\treturn this.title;\n\t}\n\t}\n\t\npublic class Demo \n{\n\tpublic static void main(String[] args) \n\t{\n\t\tSystem.out.println(new Book(\"Java\").getTitle());\n\t\tSystem.out.println(new Book(\"JSP\").getTitle());\n\t\tSystem.out.println(new Book(\"Spring\").getTitle());\n\t\tSystem.out.println(new Book().getTitle());\n\t\tSystem.out.println(new Book().getTitle());\n\t}\n\t\t\n}\n\n  ```","tags":["this"],"categories":["Java基础语法"]},{"title":"random基础语法","url":"/2021/11/08/random基础语法/","content":"### random的使用 ###\nrandom.random()用于生成一个0到1的随机浮点数：0<=n<1.0（左闭右开）\n\n```\nimport random\nret = random.random()\nprint(ret)\n结果：\nret : 0.8947529143749732\n```\nrandom.uniform(a,b) # 用于生成一个指定范围的随机浮点数,两个参数其中一个是上限,一个是下限,如果a>b,则生成的随机数n:a<=n<b。如果a<b,则b<=n<a\n\n```\nimport random\nret1 = random.uniform(1,10)\nret2 = random.uniform(10,1)\nprint(ret1)\nprint(ret2)\n结果：\nret1 : 3.674080751273465\nret2 : 4.428659179457661\n```\nrandom.randint(a,b) # 用于生成一个指定范围内的整数,其中参数a是下限,参数b是上限,生成的随机数n:a<=n<b\n\n```\nimport random\nret = random.randint(1,10)\nprint(ret)\n结果：\nret : 5\n```\nrandom.choice(sequence) # random.choice从序列中获取一个随机元素,\nrandom.shuffle(x[,random]) # 用于将一个列表中的元素打乱,即将列表内的元素随机排序\n\n```\n>>> list1\n['python', 123, [1, 2, 3], (1, 2, 3)]\n>>> random.shuffle(list1)\n>>> list1\n[123, [1, 2, 3], (1, 2, 3), 'python']\n```\n\nrandom.sample(sequence,k) # 从指定序列中随机获取指定长度的片断并随机排序。\n \n```\n>>> list1\n[123, [1, 2, 3], (1, 2, 3), 'python']\n>>> ret = random.sample(list1)\nTraceback (most recent call last):\n  File \"<pyshell#62>\", line 1, in <module>\n    ret = random.sample(list1)\nTypeError: sample() missing 1 required positional argument: 'k'\n>>> ret = random.sample(list1, 2)\n>>> ret\n[(1, 2, 3), 123]\n>>> list1\n[123, [1, 2, 3], (1, 2, 3), 'python']\n```\n","tags":["Python"],"categories":["基础语法"]},{"title":"方法的定义与使用","url":"/2021/11/07/方法的定义与使用/","content":"### 方法简介 ###\n&emsp; &emsp;&emsp;  方法：一段可以被重复调用的代码段。\n\n法定义语法：\n\n```\npublic static 返回值类型 方法名称(参数类型 参数变量, ...) {\n\t\t\t方法体（本方法要执行的若干操作） ;\n\t\t\t[return [返回值] ;]\n\t\t}\n   \n```\n\n\n\n\n### 定义一个无参数接收并且无返回值的方法 ###\n\n\n```\npublic class JavaDemo {\n\tpublic static void main(String args[]) {\n\t\tprintInfo(); \t\t// 方法调用\n\t\tprintInfo(); \t\t// 方法调用\n\t} \n\t/**\n\t * 定义一个打印信息的方法，该方法不需要接受参数并且不返回任何处理结果 \n\t */\n\tpublic static void printInfo() { \t// 该方法包含了三行代码\n\t\tSystem.out.println(\"*******************\") ;\n\t\tSystem.out.println(\"*  www.yootk.com  *\") ;\n\t\tSystem.out.println(\"*******************\") ;\n\t}\n}\n```\n\n\n\n### 定义一个有参数有返回值的方法 ###\n\n\n```\npublic class JavaDemo {\n\tpublic static void main(String args[]) {\n\t\tString result = payAndGet(20.0);// 调用方法并接收返回值\n\t\tSystem.out.println(result);\t// 输出操作结果\n\t\tSystem.out.println(payAndGet(1.0)); // 返回值可以直接输出\n\t}\n\t/**\n\t * 定义一个支付并获取内容的方法，该方法可以由主方法直接调用 \n\t * @param money 要支付的金额\n\t * @return 根据支付结果获取相应的反悔信息\n\t */\n\tpublic static String payAndGet(double money) {\n\t\tif (money >= 10.0) {// 判断购买金额是否充足\n\t\t\treturn \"购买一份快餐，找零：\" + (money - 10.0);\n\t\t} else {// 金额不足\n\t\t\treturn \"对不起，您的余额不足，请先充值，或者捡漏。\";\n\t\t}\n\t}\n}\n\n    ```\n\n\n### 使用return结束方法调用 ###\n\n\n```\npublic class JavaDemo {\n\tpublic static void main(String args[]) {\n\t\tsale(3);\t// 调用方法 \n\t\tsale(-3);\t// 调用方法\n\t}\n\t/**\n\t * 定义销售方法，可以根据金额输出销售信息\n\t * @param amount 要销售的数量，必须为正数\n\t */\n\tpublic static void sale(int amount) {\n\t\tif (amount <= 0) { // 销售数量出现错误\n\t\t\treturn; \t// 后续代码不执行了\n\t\t}\n\t\tSystem.out.println(\"销售出\" + amount + \"本图书。\");\n\t}\n}\n\n     ```\n\n### 方法重载 ###\n方法重载是方法名称进行重用的一种技术形式，其最主要的特点为：“方法名称相同，参数的类型或个数不同”，在调用时会根据传递的参数类型和个数不同执行不同的方法体。\n\n```\npublic class JavaDemo {\n\tpublic static void main(String args[]) {\n\t\tint resultA = sum(10, 20); // 调用两个int参数的方法\n\t\tint resultB = sum(10, 20, 30); // 调用三个int参数的方法\n\t\tint resultC = sum(11.2, 25.3);// 调用两个double参数方法\n\t\tSystem.out.println(\"加法执行结果：\" + resultA);\n\t\tSystem.out.println(\"加法执行结果：\" + resultB);\n\t\tSystem.out.println(\"加法执行结果：\" + resultC);\n\t}\n\tpublic static int sum(int x, int y) {\n\t\treturn x + y;// 两个数字相加\n\t}\n\tpublic static int sum(int x, int y, int z) {\n\t\treturn x + y + z;\t// 三个数字相加\n\t}\n\tpublic static int sum(double x, double y) {\n\t\treturn (int) (x + y);\t// 两个数字相加\n\t}\n}\n\n```\n\n\n### 方法递归调用 ###\n定义：一个方法自己调用自己，注意一下几个问题：\n- 一定要设置方法结束调用的条件\n- 每次调用的时候，修改传递参数\nps：计算1+2+3+....+100\n\n```\npublic class JavaDemo {\n\tpublic static void main(String args[]) {\n\t\tSystem.out.println(sum(100)); // 1 - 100累加\n\t}\n\t/**\n\t * 数据的累加操作，传入一个数据累加操作的最大值，而后每次进行数据的递减，将一直累加到计算数据为1\n\t * @param num 要进行累加的操作\n\t * @return 数据的累加结果\n\t */\n\tpublic static int sum(int num) { \t// 最大的内容\n\t\tif (num == 1) { \t// 递归的结束调用\n\t\t\treturn 1; \t// 最终的结果返回了一个1\n\t\t}\n\t\treturn num + sum(num - 1); \t// 递归调用\n\t}\n}\n\n\n```\n\nps：计算1！+2！...+100！\n\n```\npublic class  Method\n{\npublic static void main(String[] args) \n\t{\n\t\tSystem.out.println(sum100));\n\t}\npublic static double sum(int num){\n\t\n\tif (num==1)\n\t{\n\t\treturn 1;\n\t}\n\treturn fun(num)+sum(num-1);\n}\npublic static double fun(int num){\n\t\n\tif (num==1)\n\t{\n\t\treturn 1;\n\t}\n\treturn num*fun(num-1);\n}\n\t}\n```\n","tags":["Java"],"categories":["基础语法"]},{"title":"进程和线程","url":"/2021/11/06/进程和线程/","content":"## 多进程编程 ##\n#### 什么是并发编程？ ####\n- 并发编程是一种充分发挥硬件性能的多任务程序设计模式，单核CPU环境下一个时间段上会有多个程序并行执行，但是在同一个时间点上只允许执行一个进程，并发编程有三种形式`多进程编程、多线程编程、多协程编程` \n\n### 什么是进程 ###\n- 进程（Process）是系统进行资源分配的调度运行的基本单位，一个进程组成有三部分`程序、数据、进程控制块 PCB`\n<table><tr>   <td bgcolor = SteelBlue ><font color = white >\n  &emsp;&emsp;缩进的快速实现，全角空格+&emsp;配合互补：正常输入时全角空格最快捷，列表后用两个&emsp;缩进，之后便可恢复全角空格方式。\n</td></tr></table>\n- 进程是一个动态的实体：\n              1. 创建状态：分配一个PCB\n              2. 就绪状态：除CPU全部资源，等待CPU调度\n              3. 执行状态：获得CPU，开始执行\n              4.  阻塞状态：暂停\n              5.  终止状态   \n- 早起的磁盘操作系统（Disk Operating System）简称DOS系统，采用单进程处理模式，同一个时间段系统所有你资源只为一个程序服务。\n- Python多进程编程可以通过 multiprocessing模块实现，在该模块中有专门的处理类 Process\n- `multiprocessing.current_process()函数`动态获取当前正在执行的进程对象\n```\n#coding:UTF-8\nimport multiprocessing,time #导入模块\nmultiprocess.current_process().pid   #获取进程ID\nmultiprocess.current_process().name   #获取进程name\ntime.sleep(delay=3s)       #延迟3s，减缓程序执行\n```\n```\n#encoding:UTF-8\nimport multiprocessing,time\ndef worker(delay,count):\n    for num in range(1,count+1):\n        print(\"[%s]进程ID：%s、进程名称：%s\"\n              %(num,multiprocessing.process.current_process().pid,\n                multiprocessing.current_process().name))\n        time.sleep(delay)  #延迟操作，delay秒\n\n\tdef main():\n    for item in range(1,4):\n        process=multiprocessing.Process(target=worker,args=(1,10),name=\"DF-%s\"%item)\n        #创建三个进程，进程名称为DF-1,DF-2，DF-3注意Process中，首字母一定要大写，否则会报错\n        process.start()  #进程启动，进入程序的调度队列，等待资源得分配\n    # process = multiprocessing.Process(target=worker, args=(1, 10), name=\"DF1586\")\n    # process.start()\n\n\tif __name__ == \"__main__\":\n    main()\n\n                 ```","tags":["并发编程"],"categories":["进程和线程"]},{"title":"Markdown&Mermaid","url":"/2021/11/03/markdown/","content":"\n# Markdown、Mermaid工具介绍  #\n### Markdown简介：Markdown 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 ###\n### Mermaid简介：Mermaid 是一个用于画流程图、状态图、时序图、甘特图的库，使用 JS 进行本地渲染，广泛集成于许多 Markdown 编辑器中。 ###\n\n### Mermaid在线编辑工具[https://mermaid.live/](https://mermaid.live/ \"Mermaid在线编辑工具\") ### \n![mermaid在线编辑.png](https://i.loli.net/2021/11/05/pzljqfSceJD5iH2.png)\n![上传到markdown展示.png](https://i.loli.net/2021/11/05/UD3f2CRJd1Nnsji.png)\n###  Mermaid的教程[https://blog.csdn.net/weixin_28701593/article/details/113586750](https://blog.csdn.net/weixin_28701593/article/details/113586750 \"Mermaid教程\") ###\n\n### Markdownpad官方下载地址：[http://markdownpad.com/](http://markdownpad.com/ \"MarkdownPad下载\")  ###\n\n### Markdownpad官方下载地址：[http://markdownpad.com/](http://markdownpad.com/ \"MarkdownPad下载\") ###\n![markdown官网.png](https://i.loli.net/2021/11/05/VWrtJpg7LDGn3FE.png)\n \n在使用该语法时开头之前必须要有一行空行，若要标记语言则在开头语法加一个空格然后声明语言类型(具体如图所示)，既然开头有要求自然结束也有要求的。结束时切忌不要在结束标签后加空格，否则该标签未关闭。关闭则直接回车换两行即可。这就是让我痛不欲生错误啊，该问题在编译器里是看不出异常的，编译器里预览效果都是正常的包括直接用浏览器预览也是正常的，但实际并不是这样的，当你生成hexo博客后就会发现异常。详见链接：\n[https://blog.csdn.net/qq_37165235/article/details/103614844?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163625371516780366562470%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=163625371516780366562470&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-5-103614844.first_rank_v2_pc_rank_v29&utm_term=markdown%E5%A4%9A%E4%B8%AA%E4%BB%A3%E7%A0%81%E5%9D%97%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8&spm=1018.2226.3001.4187](https://blog.csdn.net/qq_37165235/article/details/103614844?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163625371516780366562470%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=163625371516780366562470&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-5-103614844.first_rank_v2_pc_rank_v29&utm_term=markdown%E5%A4%9A%E4%B8%AA%E4%BB%A3%E7%A0%81%E5%9D%97%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8&spm=1018.2226.3001.4187 \"代码块引用时的一些错误\")\n","tags":["markdown"],"categories":["mycategories"]},{"title":"类和对象","url":"/2021/11/03/类和对象/","content":"### 类和对象 ###\n面向对象是现在最为流行的软件设计与开发方法。\n#### 面向过程与面向对象的区别 ####\n\n*面向过程：* 由个人准备好所有制造机器的材料，然后按照自己的标准制造机器人，这样制造的机器人不具备通用性。\n*面向对象：*由设计团队将机器人的制造工艺进行拆分，而后详细设计出每一个部件的定义标准抑菌剂各个部件之间的连接标准，随后将这些设计标准交付响应的工厂进行制造，每个工厂的流水线只能完成一个零部件的生产，最后再一起进行拼接。\n#### 面向对象编程的三大主要特点 ####\n- 封装性\n- 继承性\n- 多态性\n#### 类与对象 ####\n\n面向对象编程中*类*和*对象*是基本的组成单元，类是对一个客观群体特征的抽象描述，而对象表示的一个个具体的可操作实物。\n类是对象的模板  而对象是类的实例\n\n[![](https://mermaid.ink/img/eyJjb2RlIjoiZ3JhcGggTFJcbiAgICBBW-exu-eahOWfuuacrOe7hOaIkOWNleWFg10gLS0-IEIxKOWxnuaApylcbiAgICBBLS0-QjIo5pa55rOVKVxuICAgIEIxLS0-5a6e5L6L5bGe5oCnXG4gICAgQjEtLT7nsbvlsZ7mgKdcbiAgICBCMi0tPueUqOS6juaPj-i_sOWKn-iDvVxuICAgIFxuICAgXG4gICIsIm1lcm1haWQiOnsidGhlbWUiOiJkZWZhdWx0In0sInVwZGF0ZUVkaXRvciI6ZmFsc2UsImF1dG9TeW5jIjp0cnVlLCJ1cGRhdGVEaWFncmFtIjpmYWxzZX0)](https://mermaid.live/edit#eyJjb2RlIjoiZ3JhcGggTFJcbiAgICBBW-exu-eahOWfuuacrOe7hOaIkOWNleWFg10gLS0-IEIxKOWxnuaApylcbiAgICBBLS0-QjIo5pa55rOVKVxuICAgIEIxLS0-5a6e5L6L5bGe5oCnXG4gICAgQjEtLT7nsbvlsZ7mgKdcbiAgICBCMi0tPueUqOS6juaPj-i_sOWKn-iDvVxuICAgIFxuICAgXG4gICIsIm1lcm1haWQiOiJ7XG4gIFwidGhlbWVcIjogXCJkZWZhdWx0XCJcbn0iLCJ1cGRhdGVFZGl0b3IiOmZhbHNlLCJhdXRvU3luYyI6dHJ1ZSwidXBkYXRlRGlhZ3JhbSI6ZmFsc2V9)\n\n","tags":["python"],"categories":["mycategories"]},{"title":"python-2","url":"/2021/11/01/python-2/","content":"### python语言的优点  ###\n\n- 优雅  明确 简单  \n### python 可以做什么 ###\n- 网站后端程序员：使用python搭建网站，例如Gmail、Youtube、Reddit、知乎、豆瓣\n- 自动化运维\n- 数据分析师\n- 游戏开发\n- 自动化测试\n- 网站的开发 Django flask bootstrap\n- 用爬虫爬取或处理大量信息 批量下载枚举、爬合适房源、刷折扣机票、运行投资策略\n### 变量与字符串 ###\n- 变量是编程中最基本的存储单位\n- 变量的名称叫标识符\n- 给变量a赋值42 `a=42`\n- print()打印函数\n- type（）查看类型函数\n- 数据类型有：`int、float、str、dict、set、list、、tuple、bool`\n- len（）计算长度函数\n###  字符串的切片与索引###\n- string='helloworld'\n- string[1:5]=trin  原则：左闭右开原则\n- replace（old，new）\n- find(str，开始索引，结束索引) 返回开始的索引值\n\n### 字符串的格式化输出  ###\n    print('{} a word she can get what she {} for.'.format('with','came'))\n    print('{0} a word she can get what she {1} for.'.format('with','came'))\n\n### 函数 ###\n- def（define） 创建一个函数\n- arg (argument)   参数\n- return   返回结果\n- insert(1，apple)  插入\n- extend（列表）为一个列表追加另外一个列表\n- append（data）添加单个元素\n- clear()清楚列表数据\n- copy()列表复制\n- count(data)统计某一个数据在列表中出现的次数\n- index(data) 从列表中查询某个数据第一次出现的位置\n- reverse()反转\n- sort()列表数据排序\n- remove(data)从列表删除数据\n- pop(index)从列表弹出一个数据删除\n- id()获取列表地址信息\n- split(',')将字符串用','分开\n- strip()\n###  字典的特征###\n- 字典中的数据是以键值对的形式出现的：`key  value`\n- 键是不能重复，而值可以\n- 字典中的key是不能修改的，而值可以改变，可以是任何对象\n- 字典在索引内容的时候跟列表一样，例如 dict[key]\n###集合的特征  ###\n\n- 每个集合中的元素是无序的、不重复的任意对象\n- 利用集合可以把数据结构中重复的元素减掉\n- a_set={1,2,3,4,5}\n- a_set.add(6)  添加元素\n- a_set.discard(6)  删除元素\n","tags":["python"],"categories":["python"]}]